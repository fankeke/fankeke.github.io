<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="前言在nginx中，有两个常用的限速模块 limit_conn 与limit_req，他们两者使用的场景各异，下面试图从源码视角来分析这两个模块的实现。这两个限速模块是典型的使用共享内存的模块，在分析这两个模块的过程中，顺便可以学习nginx是如何使用共享内存。 1 实现方式两个模块都是在preaccess阶段插入的handler钩子，每个请求来时都会经过handler处理一遍。 12345678">
<meta property="og:type" content="article">
<meta property="og:title" content="源码剖析NGINX中的限速模块">
<meta property="og:url" content="http://yoursite.com/2019/09/30/源码剖析NGINX中的限速模块/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="前言在nginx中，有两个常用的限速模块 limit_conn 与limit_req，他们两者使用的场景各异，下面试图从源码视角来分析这两个模块的实现。这两个限速模块是典型的使用共享内存的模块，在分析这两个模块的过程中，顺便可以学习nginx是如何使用共享内存。 1 实现方式两个模块都是在preaccess阶段插入的handler钩子，每个请求来时都会经过handler处理一遍。 12345678">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/22a870dcdd2a06cf6605a4b441044fc8.png">
<meta property="og:updated_time" content="2019-09-30T13:44:19.886Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="源码剖析NGINX中的限速模块">
<meta name="twitter:description" content="前言在nginx中，有两个常用的限速模块 limit_conn 与limit_req，他们两者使用的场景各异，下面试图从源码视角来分析这两个模块的实现。这两个限速模块是典型的使用共享内存的模块，在分析这两个模块的过程中，顺便可以学习nginx是如何使用共享内存。 1 实现方式两个模块都是在preaccess阶段插入的handler钩子，每个请求来时都会经过handler处理一遍。 12345678">
<meta name="twitter:image" content="https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/22a870dcdd2a06cf6605a4b441044fc8.png">
  <link rel="canonical" href="http://yoursite.com/2019/09/30/源码剖析NGINX中的限速模块/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>源码剖析NGINX中的限速模块 | 个人博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">长生不老</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/源码剖析NGINX中的限速模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">源码剖析NGINX中的限速模块

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 22:12:23 / 修改时间：21:44:19" itemprop="dateCreated datePublished" datetime="2019-09-30T22:12:23+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>11k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>10 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在nginx中，有两个常用的限速模块 limit_conn 与limit_req，他们两者使用的场景各异，下面试图从源码视角来分析这两个模块的实现。这两个限速模块是典型的使用共享内存的模块，在分析这两个模块的过程中，顺便可以学习nginx是如何使用共享内存。</p>
<h3 id="1-实现方式"><a href="#1-实现方式" class="headerlink" title="1 实现方式"></a>1 实现方式</h3><p>两个模块都是在preaccess阶段插入的handler钩子，每个请求来时都会经过handler处理一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">limit_req</span><br><span class="line"></span><br><span class="line">h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers);</span><br><span class="line">if (h == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">*h = ngx_http_limit_req_handler;</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line">limit_conn</span><br><span class="line"></span><br><span class="line">h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers);</span><br><span class="line">if (h == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">*h = ngx_http_limit_zone_handler;</span><br></pre></td></tr></table></figure>

<h3 id="2-配置解析"><a href="#2-配置解析" class="headerlink" title="2 配置解析"></a>2 配置解析</h3><p>首先是共享内存的定义，由于两个模块都在配置上都相似，下面以limit_req的配置为切入点，观察配置与源码的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone  $binaray_remote_addr zone=one:10m rate=10r/s;</span><br></pre></td></tr></table></figure>

<p>这一行定义了一块共享内存，其中key为ip地址(一般key都为变量方式），大小为10m，名称为one，在limit_req场景下限速为每秒允许10个key。注意这写属性都是共享内存的属性，与location以及请求都没有关系。</p>
<p>关键成员解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_limit_req_ctx_t));</span><br><span class="line">if (ctx == NULL) &#123;</span><br><span class="line">    return NGX_CONF_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;index = ngx_http_get_variable_index(cf, &amp;value[i]);</span><br><span class="line">if (ctx-&gt;index == NGX_ERROR) &#123;</span><br><span class="line">    return NGX_CONF_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;var = value[i];</span><br></pre></td></tr></table></figure>

<p>这里将变量的index存放在ctx上: ctx-&gt;index = ngx_http_get_variable_index(cf, &amp;value[i]);</p>
<p>nginx中常见这种写法：如果需要使用某个变量，则将该变量的index存放在结构体中，但这里需要注意的是，ctx这个名称一般都是与请求粒度相关的，请求销毁了，ctx也将销毁，但这里将ctx存放在了全局空间，申请在ctx=palloc(cf-&gt;pool,xxx)上， 这似乎不太符合命名规范。个人认为最好取名为zone_ctx, 即共享内存的上下文属性。</p>
<p>另外，由于这些成员没有存放在xlcf等location相关的结构体中，在后续使用的时候如何找到这里的ctx呢？答案是通过共享内存shm。由于ctx是和某个shm强相关，理所当然需要和相应的shm bind在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shm_zone = ngx_shared_memory_add(cf, &amp;name, size,</span><br><span class="line">                                     &amp;ngx_http_limit_req_module);</span><br><span class="line">shm_zone-&gt;init = ngx_http_limit_req_init_zone;</span><br><span class="line">shm_zone-&gt;data = ctx;</span><br></pre></td></tr></table></figure>

<p>这里shm_zone的data将其联系在一起。那么问题是，如果找到某个指定的shm？是通过共享内存的名称即可。<br><code>ngx_shared_memory_add(cf, &amp;name, 0, &amp;ngx_http_limit_req_module)</code>即可找到相应的shm。</p>
<p>而后续如果要使用shm，那么肯定需要提供name来找到，这样就将各个变量的衔接打通了。</p>
<h3 id="3-shm初始化与使用"><a href="#3-shm初始化与使用" class="headerlink" title="3 shm初始化与使用"></a>3 shm初始化与使用</h3><p>上面只是定义了shm的各个属性，没有具体将shm初始化以及组织，而初始化由各个使用模块自定义。下面以limit_req模块对shm的初始化为例进行分析：</p>
<p>初始化的钩子是<code>ngx_http_limit_req_init_zone</code><br>整个初始化的过程实际体现在如何给相关ctx赋值(前面提到的zone_ctx),来具体看下ctx的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_http_limit_req_shctx_t  *sh;</span><br><span class="line">    ngx_slab_pool_t             *shpool;</span><br><span class="line">    /* integer value, 1 corresponds to 0.001 r/s */</span><br><span class="line">    ngx_uint_t                   rate;</span><br><span class="line">    ngx_int_t                    index;</span><br><span class="line">    ngx_str_t                    var;</span><br><span class="line">&#125; ngx_http_limit_req_ctx_t;</span><br></pre></td></tr></table></figure>

<p>在申请shm的时候，rate、index、var等值已经被赋值过了，这里shpool是通过slab机制来使用shm的内存空间，是框架相关的机制，可以暂时不用关心(只需要知道使用slab机制可以高效地使用shm），后续对shm的内存分配都是通过ctx-&gt;shpool,不会直接在shm中分配，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx-&gt;sh = ngx_slab_alloc(ctx-&gt;shpool, sizeof(ngx_http_limit_req_shctx_t));</span><br><span class="line">if (ctx-&gt;sh == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么具体的组织细节体现在对sh的赋值上，这也是每片内存所独有的组织方式，看下sh的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ypedef struct &#123;</span><br><span class="line">    ngx_rbtree_t                  rbtree;</span><br><span class="line">    ngx_rbtree_node_t             sentinel;</span><br><span class="line">    ngx_queue_t                   queue;</span><br><span class="line">&#125; ngx_http_limit_req_shctx_t;</span><br></pre></td></tr></table></figure>

<p>基本上将该片shm是通过红黑树和队列的方式组织的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_rbtree_init(&amp;ctx-&gt;sh-&gt;rbtree, &amp;ctx-&gt;sh-&gt;sentinel,</span><br><span class="line">                    ngx_http_limit_req_rbtree_insert_value);</span><br><span class="line">    ngx_queue_init(&amp;ctx-&gt;sh-&gt;queue);</span><br></pre></td></tr></table></figure>

<p>这里多说一下，在limit_conn中，只有rbtree的方式，后面会分析到在limit_conn场景中，只有快速插入、查找的需求，而在limit_req中，多了queue的组织方式，这里的queue是用来做lrucache，为了避免内存溢出，将访问时间近的节点插入队头。</p>
<p>在初始化shm的时候还有一个地方值得注意<br><code>ctx-&gt;shpool-&gt;data = ctx-&gt;sh;</code></p>
<p>为啥要有这样的操作：主要是为了判断是否已经初始化这片shm，防止二次初始化，和业务逻辑没有关系，是shm框架使用。</p>
<ul>
<li>使用shm<br>shm初始化完毕后，将通过location级别的指令指定使用那块shm，看下配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_zone=one burst=5 nodelya</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过名称指定使用哪块内存，将其保存在lcf结构中，这是location级别相关的存储结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_shm_zone_t              *shm_zone;</span><br><span class="line">    /* integer value, 1 corresponds to 0.001 r/s */</span><br><span class="line">    ngx_uint_t                   burst;</span><br><span class="line">    ngx_uint_t                   nodelay; /* unsigned  nodelay:1 */</span><br><span class="line">&#125; ngx_http_limit_req_conf_t;</span><br></pre></td></tr></table></figure>

<p>其中shm_zone指向shm，burst和nodelay直接解析指令可以得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrcf-&gt;shm_zone = ngx_shared_memory_add(cf, &amp;s, 0,</span><br><span class="line">                                                   &amp;ngx_http_limit_req_module);</span><br></pre></td></tr></table></figure>

<p>即通过名称找到先前初始化ok的shm。</p>
<p>小结：以上是配置解析过程，总的来说就是将shm初始化完毕，然后通过name找到将要使用的shm联系起来。从中可以学习到shm的一般使用流程。</p>
<h3 id="4-算法流程"><a href="#4-算法流程" class="headerlink" title="4 算法流程"></a>4 算法流程</h3><p>下面是每个请求流过handler时候的逻辑，也是限流算法的核心：针对每个请求级别生效。对于limit_conn来说比较简单，先分析其handler： <code>ngx_http_limit_zone_handler</code></p>
<ul>
<li>limit_conn</li>
</ul>
<p>1 首先判断，这个r进入的location是否有定义限速：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lccf = ngx_http_get_module_loc_conf(r, ngx_http_limit_conn_module);</span><br><span class="line">    if (lccf-&gt;shm_zone == NULL) &#123;</span><br><span class="line">        return NGX_DECLINED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>若该location没有设定限速，则直接跳过。（若设置了限速，lccf-&gt;shm_zone的值会指向某块内存，前面已述。</p>
<p>2 取出请求上变量值、查找<br><code>vv = ngx_http_get_indexed_variable(r, ctx-&gt;index);</code><br>根据值在rbtree上进行查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">while (node != sentinel) &#123;</span><br><span class="line">        if (hash &lt; node-&gt;key) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;   </span><br><span class="line">        if (hash &gt; node-&gt;key) &#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        /* hash == node-&gt;key */</span><br><span class="line">        lz = (ngx_http_limit_zone_node_t *) &amp;node-&gt;color;</span><br><span class="line">        rc = ngx_memn2cmp(vv-&gt;data, lz-&gt;data, len, (size_t) lz-&gt;len);</span><br><span class="line">        if (rc == 0) &#123;</span><br><span class="line">            if ((ngx_uint_t) lz-&gt;conn &lt; lzcf-&gt;conn) &#123;</span><br><span class="line">                lz-&gt;conn++;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            ngx_shmtx_unlock(&amp;shpool-&gt;mutex);</span><br><span class="line">            ngx_log_error(lzcf-&gt;log_level, r-&gt;connection-&gt;log, 0,</span><br><span class="line">                          &quot;limiting connections by zone \&quot;%V\&quot;&quot;,</span><br><span class="line">                          &amp;lzcf-&gt;shm_zone-&gt;shm.name);</span><br><span class="line">            return NGX_HTTP_SERVICE_UNAVAILABLE;</span><br><span class="line">        &#125;</span><br><span class="line">        node = (rc &lt; 0) ? node-&gt;left : node-&gt;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑也是十分直接：若rbtree中有相应节点，判断节点的lr-&gt;conn是否超过设定location的lzcf-&gt;conn值，若没有超过，则增加该key的lr-&gt;conn值，然后直接放过，若超过了，则直接503掉。</p>
<p>至于放过后的请求，需要做收尾处理：当请求处理完成后，需要将lr-&gt;conn的值恢复，cleanup适合做这件事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cln = ngx_pool_cleanup_add(r-&gt;pool, sizeof(ngx_http_limit_zone_cleanup_t));</span><br><span class="line">（cln可以申请一块空间作为handler的参数：cln-&gt;data</span><br><span class="line">cln-&gt;handler = ngx_http_limit_zone_cleanup;</span><br><span class="line">lzcln = cln-&gt;data;</span><br><span class="line">lzcln-&gt;shm_zone = lzcf-&gt;shm_zone;</span><br><span class="line">lzcln-&gt;node = node;</span><br><span class="line"></span><br><span class="line">定义如下</span><br><span class="line"></span><br><span class="line">ngx_http_limit_zone_cleanup&#123;</span><br><span class="line">lz-&gt;conn--;</span><br><span class="line">    if (lz-&gt;conn == 0) &#123;</span><br><span class="line">        ngx_rbtree_delete(ctx-&gt;rbtree, node);</span><br><span class="line">        ngx_slab_free_locked(shpool, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将相应节点的conn恢复，若发现为0了，则将相应节点从rbtree中摘掉。</p>
<p>cleanup机制在nginx中使用十分场景，它提供了相当优雅的价值，为结束请求收尾处理提供了便利。</p>
<p>回到上面，如果没有在rbtree中找到相应key，则申请节点空间后插入rbtree,并初始化相应节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = offsetof(ngx_rbtree_node_t, color)</span><br><span class="line">        + offsetof(ngx_http_limit_zone_node_t, data)</span><br><span class="line">        + len;</span><br><span class="line">    node = ngx_slab_alloc_locked(shpool, n);</span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        ngx_shmtx_unlock(&amp;shpool-&gt;mutex);</span><br><span class="line">        return NGX_HTTP_SERVICE_UNAVAILABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    lz = (ngx_http_limit_zone_node_t *) &amp;node-&gt;color;</span><br><span class="line">    node-&gt;key = hash;</span><br><span class="line">    lz-&gt;len = (u_char) len;</span><br><span class="line">    lz-&gt;conn = 1;</span><br><span class="line">    ngx_memcpy(lz-&gt;data, vv-&gt;data, len);</span><br></pre></td></tr></table></figure>

<ul>
<li>小结：limit_conn的算法就是这样，从代码中分析可以看出，limit_conn的限速是一个存量的限速状态。</li>
</ul>
<h4 id="limit-req"><a href="#limit-req" class="headerlink" title="limit_req"></a>limit_req</h4><p>下面分析稍微复杂一些的limit_req限速：其算法和典型的漏桶算法限速有些类似。在此之前先了解下什么是漏桶算法：</p>
<p><img src="https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/22a870dcdd2a06cf6605a4b441044fc8.png" alt="image.png"></p>
<p>一个形象的解释是</p>
<ul>
<li>水（请求）从上方倒入水桶，从水桶下方流出（被处理）；</li>
<li>来不及流出的水存在水桶中（缓冲），以固定速率流出；</li>
<li>水桶满后水溢出（丢弃）。<br>这个算法的核心是：缓存请求、均匀处理、多余请求直接丢弃。</li>
</ul>
<p>有了对算法形象的理解，再结合代码看nginx是如何实现该算法。</p>
<p>1 和limit_conn类似，首先判断该location是否开启了limit_req</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrcf = ngx_http_get_module_loc_conf(r, ngx_http_limit_req_module);</span><br><span class="line">    if (lrcf-&gt;shm_zone == NULL) &#123;</span><br><span class="line">        return NGX_DECLINED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2 计算限速变量、查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rc = ngx_http_limit_req_lookup(lrcf, hash, vv-&gt;data, len, &amp;excess);</span><br></pre></td></tr></table></figure>

<p>这里的返回值有几种情况：OK、BUSY、AGAIN、DECLINE<br>从简单的说起<br>DECLINE表示未查到相应节点，此时申请节点空间、初始化赋值后直接插入rbtree、queue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">if (rc == NGX_DECLINED) &#123;</span><br><span class="line"></span><br><span class="line">       n = offsetof(ngx_rbtree_node_t, color)</span><br><span class="line">           + offsetof(ngx_http_limit_req_node_t, data)</span><br><span class="line">           + len;</span><br><span class="line"></span><br><span class="line">       node = ngx_slab_alloc_locked(ctx-&gt;shpool, n);</span><br><span class="line">       if (node == NULL) &#123;</span><br><span class="line"></span><br><span class="line">           ngx_http_limit_req_expire(ctx, 0);</span><br><span class="line"></span><br><span class="line">           node = ngx_slab_alloc_locked(ctx-&gt;shpool, n);</span><br><span class="line">           if (node == NULL) &#123;</span><br><span class="line">               ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex);</span><br><span class="line">               return NGX_HTTP_SERVICE_UNAVAILABLE;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       lr = (ngx_http_limit_req_node_t *) &amp;node-&gt;color;</span><br><span class="line"></span><br><span class="line">       node-&gt;key = hash;</span><br><span class="line">       lr-&gt;len = (u_char) len;</span><br><span class="line"></span><br><span class="line">       tp = ngx_timeofday();</span><br><span class="line">       lr-&gt;last = (ngx_msec_t) (tp-&gt;sec * 1000 + tp-&gt;msec);</span><br><span class="line"></span><br><span class="line">       lr-&gt;excess = 0;</span><br><span class="line">       ngx_memcpy(lr-&gt;data, vv-&gt;data, len);</span><br><span class="line"></span><br><span class="line">       ngx_rbtree_insert(&amp;ctx-&gt;sh-&gt;rbtree, node);</span><br><span class="line"></span><br><span class="line">       ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;queue, &amp;lr-&gt;queue);</span><br><span class="line"></span><br><span class="line">       ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">       return NGX_DECLINED;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很清晰：先申请空间，若空间不够，则从queue中进行lru淘汰一些节点（其实是直接从队尾删除，访问时间最久的点放在队尾）。 初始化节点，插入tree，插入queue首。直接返回，将请求交给下一个handler处理。</p>
<p>返回OK： 说明没有超过相应限速值，直接放过；<br>返回BUSY：    超过限速值，且漏桶容量不够，直接503掉；<br>返回AGAIN：超过限速值，但漏桶容量够，进一步看是否需要delay/delay处理，如果设置了nodelay，那么效果和返回OK一样，立即放行，如果没有设置，那么需要delay处理，nginx实现dealy处理的方法是，将该请求放入timer中，将该请求可写事件加入timer树。</p>
<p>如果结合漏桶算法的场景，这里的桶是指每个key都会有自己的桶。</p>
<p>回到lookup中去，漏桶算法的思想在其中：(截取）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">if (rc == 0) &#123;</span><br><span class="line">    ngx_queue_remove(&amp;lr-&gt;queue);</span><br><span class="line">    ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;queue, &amp;lr-&gt;queue);</span><br><span class="line"></span><br><span class="line">    tp = ngx_timeofday();</span><br><span class="line"></span><br><span class="line">    now = (ngx_msec_t) (tp-&gt;sec * 1000 + tp-&gt;msec);</span><br><span class="line">    ms = (ngx_msec_int_t) (now - lr-&gt;last);</span><br><span class="line"></span><br><span class="line">    excess = lr-&gt;excess - ctx-&gt;rate * ngx_abs(ms) / 1000 + 1000;</span><br><span class="line"></span><br><span class="line">    if (excess &lt; 0) &#123;</span><br><span class="line">        excess = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ep = excess;</span><br><span class="line"></span><br><span class="line">    if ((ngx_uint_t) excess &gt; lrcf-&gt;burst) &#123;</span><br><span class="line">        return NGX_BUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lr-&gt;excess = excess;</span><br><span class="line">    lr-&gt;last = now;</span><br><span class="line"></span><br><span class="line">    if (excess) &#123;</span><br><span class="line">        return NGX_AGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果查找到了相应key，先将其插入queue头，更新访问lr-&gt;last。漏洞算法的核心在这一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">excess = lr-&gt;excess - ctx-&gt;rate * ngx_abs(ms) / 1000 + 1000;</span><br></pre></td></tr></table></figure>

<p>其中lr-&gt;excess表示该key还剩多少请求未被处理，其更新方式为 : 上一次遗留 -  在此段时间已经处理的个数(如果按照限定的速度来估算）。</p>
<p>若遗留的数据以及超过了桶的大小(lrcf-&gt;burst),那么返回busy,将拒掉请求。</p>
<p>如果excess为0，则表示可以放行请求。（桶内没有数据）</p>
<p>如果不为0，但也没超过桶大小，则会视nodelay配置情况进入延迟处理。</p>
<p>而在delay情况下，nginx如何结合timer进行延迟处理的？</p>
<p>1 首先计算需要delay该请求多久：excess * 1000 / ctx-&gt;rate</p>
<p>2 将可写时间加入timer，同时将请求的可读事件加入epoll</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (ngx_handle_read_event(r-&gt;connection-&gt;read, 0) != NGX_OK) &#123;</span><br><span class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;read_event_handler = ngx_http_test_reading;</span><br><span class="line">    r-&gt;write_event_handler = ngx_http_limit_req_delay;</span><br><span class="line">    ngx_add_timer(r-&gt;connection-&gt;write,</span><br><span class="line">                  (ngx_msec_t) excess * 1000 / ctx-&gt;rate);</span><br></pre></td></tr></table></figure>

<p>解析：将可写时间加入timer好理解，当timer触发式将继续执行该请求。这里首先将可读事件加入epoll中，原因是若在此期间收到了客户端的fin包，需要将该请求终止掉。</p>
<p>在可写事件的handler中： 下面贴出完整的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">ngx_http_limit_req_delay(ngx_http_request_t *r)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_event_t  *wev;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,</span><br><span class="line">                   &quot;limit_req delay&quot;);</span><br><span class="line"></span><br><span class="line">    wev = r-&gt;connection-&gt;write;</span><br><span class="line"></span><br><span class="line">    if (!wev-&gt;timedout) &#123;</span><br><span class="line"></span><br><span class="line">        if (ngx_handle_write_event(wev, 0) != NGX_OK) &#123;</span><br><span class="line">            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wev-&gt;timedout = 0;</span><br><span class="line"></span><br><span class="line">    if (ngx_handle_read_event(r-&gt;connection-&gt;read, 0) != NGX_OK) &#123;</span><br><span class="line">        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;read_event_handler = ngx_http_block_reading;</span><br><span class="line">    r-&gt;write_event_handler = ngx_http_core_run_phases;</span><br><span class="line"></span><br><span class="line">    ngx_http_core_run_phases(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种延迟处理请求的做法值得学习，忽略可读事件，调用ngx_http_core_run_phases再次进去请求的处理阶段。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个limit_conn/limit_req算法从源码上就分析完毕了，从中至少可以学习到以下知识：</p>
<p>1 shm的使用、组织、初始化</p>
<p>2 如何延迟处理请求（在C层面的实现）</p>
<p>3 漏桶算法在nginx中的实现</p>
<p>4 更加优雅地组织nginx模块。</p>
<p>谢谢</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/30/货币金融学笔记/" rel="next" title="货币金融学笔记">
                  <i class="fa fa-chevron-left"></i> 货币金融学笔记
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/01/深入理解redis中的zset对象/" rel="prev" title="深入理解redis中的zset对象">
                  深入理解redis中的zset对象 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-实现方式"><span class="nav-number">2.</span> <span class="nav-text">1 实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-配置解析"><span class="nav-number">3.</span> <span class="nav-text">2 配置解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-shm初始化与使用"><span class="nav-number">4.</span> <span class="nav-text">3 shm初始化与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-算法流程"><span class="nav-number">5.</span> <span class="nav-text">4 算法流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#limit-req"><span class="nav-number">5.1.</span> <span class="nav-text">limit_req</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/id.jpg"
      alt="josephus.ftt">
  <p class="site-author-name" itemprop="name">josephus.ftt</p>
  <div class="site-description" itemprop="description">《红与黑》</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">josephus.ftt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">57k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">52 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

</body>
</html>
