<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh_Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh_Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">无意苦争春，一任群芳妒</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/04/货币金融学笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/04/货币金融学笔记/" itemprop="url">
                  货币金融学笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-04T10:13:30+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>=====<br>仅是个人理解</p>
<h3 id="第一章-基础前言"><a href="#第一章-基础前言" class="headerlink" title="第一章 基础前言"></a>第一章 基础前言</h3><ul>
<li><p>本书将通过考察金融市场（例如债券市场、股票市场、外汇市场）和金融机构（也叫金融中介，如银行、保险公司、共同基金和其它金融机构）的运作，来探寻货币在经济中的角色。</p>
</li>
<li><p>企业在高利率的经济环境中，可能会推迟新建工厂，从而对就业产生不利影响。</p>
</li>
<li><p>债券市场可以帮助政府和企业筹集到所需要的资金，是决定利率的场所。</p>
</li>
<li><p>金融市场和金融机构的关系：金融机构是金融尺长能够运行的关键所在，没有金融机构，金融市场久无法实现资金由储蓄者相有生产性投资机会的人的转移。</p>
</li>
<li><p>银行：是（吸收存款和发放贷款的）金融机构，具体而言，又可以分为商业银行、储蓄、信贷协会、互助储蓄、信用社等。银行是经济规模中最大的金融机构。</p>
</li>
<li><p>货币与经济周期：每次经济衰退前，都伴随着货币增长率的下降，说明货币供给的变动是经济周期波动的推动力之一。然而并非每次货币增长率下降都会出现经济衰退。</p>
</li>
<li><p>货币与通货膨胀：物价水平和货币供给的走势都相当一致，着表妹，货币供给的持续增加是物价水平持续上升（即通货膨胀）的一个重要原因。</p>
</li>
<li><p>货币政策：即对货币和利率的管理，中央银行负责货币政策的实施。</p>
</li>
<li><p>财政政策：指政府对政府支出和税收的决策。预算赤字：在一年中，政府支出超过税收，预算盈余：在一年中政府支出小于税收。</p>
<pre><code>（预算赤字可能导致较高的货币增长率、较高的通货膨胀和较高的利率 ）
</code></pre><p>（即货币政策由央行实施，财政政策由政府实施）（本国嘛，你懂的）</p>
</li>
<li><p>外汇市场： 跨国转移的资金必须由流出国的货币兑换为流入国的货币。<br>汇率的变动会影响进口成本，对消费者的影响是直接的.<br>本国汇率下跌，意味着外国商品变贵，出国度假（服务）变贵，会减少本国消费外国商品和服务，增加对本国消费商品和服务，提振本国就业市场。<br>本国汇率上升：意味着外国商品变便宜，会增加本国消费外国商品和服务，减少对本国消费商品和服务，冲击本国就业市场。</p>
</li>
</ul>
<h3 id="第二章-金融机构和金融市场"><a href="#第二章-金融机构和金融市场" class="headerlink" title="第二章 金融机构和金融市场"></a>第二章 金融机构和金融市场</h3><ul>
<li><p>苹果公司发明了更好的ipod，需要资金将其投放市场，此时金融市场和金融中介就登场了。同样，地方政府，相当于一个苹果公司，需要资金修建公路和建设学校，但地方税收无法<br>满足，于是向金融市场和金融机构融资，即向银行融资，等收过路费再还给银行。中国的债务问题就是，地方政府借了银行的钱建桥修路后，却收不回过路费，换不了银行的钱。</p>
</li>
<li><p>融资由两种主要手段： 通过金融市场直接融资，通过金融中介机构间接融资。<br>福特公司通过发行债券或者股票进行直接融资。也可以向银行贷款进行间接融资。</p>
</li>
<li><p>资本：可以用来创造财富的财富，他可以是金融财富也可以是物质财富。金融市场有助于资本的合理配置，从而增加生产和提高效率。<br>在经济危机期间，金融市场遭受严重破坏，经济发展受阻。</p>
</li>
<li><p>一级市场：公司或者政府机构将其新发行的股票货债券等销售给最初购买者的金融市场。<br>二级市场：交易已经发行的证券的金融市场<br>一即市场并不为公众熟知，因为将证券销售给最初购买者的过程并不是公开进行的。<br>投资银行是一级市场上协助首次出售的重要金融机构：承销这些证券。<br>纽交所、纳斯达克都是著名的二级市场。介绍金融市场的书籍会把重点放在二级市场，也应该放在二级市场。</p>
</li>
<li><p>货币市场：根据交易证券的期限长短来区分，货币市场是交易短期债务工具的金融市场 。（如国库券，可转让存单等）<br>资本市场：交易长期债务工具的金融市场  （如股票，抵押贷款，企业债券，地方政府债券</p>
</li>
<li><p>金融中介机构：间接融资。<br>当企业试图为其业务活动寻求资金来源时，它们通常会求助于金融中介机构，而非证券市场。 原因可以从三个方面来回答：交易成本，风险分担，信息成本。</p>
</li>
<li><p>金融中介机构分类：<br>存款机构（主要指银行，包括商业银行、储蓄和贷款协会，信用社）<br>契约型储蓄机构（包括人寿保险，意外保险，养老基金）<br>投资中介机构（包括财务公司，共同基金）<br>需要了解它们的资产和负债类型。</p>
</li>
</ul>
<h3 id="第三章-什么是货币"><a href="#第三章-什么是货币" class="headerlink" title="第三章 什么是货币"></a>第三章 什么是货币</h3><ul>
<li><p>本书所指的货币：在产品和服务支付以及债务偿还中被普遍接受的东西，它与收入和财富是有区别的。</p>
</li>
<li><p>货币的交易媒介功能：货币是经济社会中至关重要的东西：由于它可以降低交易成本，鼓励专业户和劳动分工，因而是经济顺利运行的润滑剂。</p>
</li>
<li><p>货币的记账单位功能：我们不会说一件衣服值3股，而会说一件衣服300元</p>
</li>
<li><p>货币的价值存储功能：货币作为价值储藏手段并非独一无二的，任何资产包括货币、股票、债券、土地、房屋等都可以用来储藏餐饭，许多资产比货币更有价值储藏功能。<br>但为啥人们还愿意持有货币呢？流动性：即某一资产转为交易媒介的便利层度和速度。由于货币本身就是交易媒介，所以具有最高的流动性，而其他资产转为交易媒介（即货币）都需要支付交易成本，（比如佣金啥的）。<br>货币作为价值储藏手段的优劣要取决于物价水平。</p>
</li>
<li><p>为何电子货币没能够彻底取代纸质货币：1 首先，需要花费加高的成购置所需的计算机、读卡器、通信网络等，2 电子支付带了安全性和私密性的问题，未经授权的黑客闯入了某个计算机数据库，并更改了其中存储的信息，要防止这种犯罪行为并非易事，需要开发一个全新的对付安全问题的计算机科学领域。3 利用电子支付方式还有一个后果，会留下有关购买习惯的大量个人信息，人们担心政府、雇主和商户会得到这些数据，从而入侵我们的私人领域。</p>
</li>
<li><p>M1 ： 最狭义的货币指标，包括流动性最强的资产，即通货、活期存款等。且其通货中之爆款非银行公众持有的纸币和硬币，不包括ATM和隐患金库中的现金。<br>M2:   在M1的基础上增加了一些流动性不及M1的资产，如定期存款等，。<br>在2008年，美国M2的数量是M1的数量的4倍左右。</p>
</li>
<li><p>M1种的通货：人均持有的现金达2000美元。这个数目是很惊人的，通货体积大，易于被窃，并且不支付任何利息，因而大部分人不可能持有这么多美元通货。但这些美元都在什么地方呢？谁在持有这些美元呢？<br>1 犯罪分子持有大量美元，因为现金交易不易被追踪。<br>2 企业愿意持有大量美元，因为现金交易很难被追踪，可以避免申报需要交税的收入<br>3 外国人由于担心本币价值贬值，不愿意相信本币，为了规避通货膨胀风险。例如俄罗斯人不信任卢布，大量持有美元。一半以上的美元都在海外。</p>
</li>
</ul>
<h3 id="第四章-理解利率"><a href="#第四章-理解利率" class="headerlink" title="第四章 理解利率"></a>第四章 理解利率</h3><ul>
<li><p>你决定要购买房子，想银行借入10W的抵押贷款，你从银行的贷款利率为7%，要想在20年换完，每年还多少钱？<br>10W＝（x／1+7%）＋（x/(1+7%)^2) + (x /(1+7%)^3) +….+(x/(1+7%)^20))<br>解答得x＝9439.29 元。</p>
</li>
<li><p>利率最精准的定义：资产的到期收益率。 （以后说道利率，都是说的是市场利率）</p>
</li>
</ul>
<h3 id="第五章-利率行为"><a href="#第五章-利率行为" class="headerlink" title="第五章 利率行为"></a>第五章 利率行为</h3><ul>
<li><p>通过债券的需求供给曲线和水果市场的需求供给曲线，感觉到债券也是一种类似于水果的商品。<br>只不过水果市场的均衡是水果的需求和供给数量的均衡，而均衡点的位置就是水果的价格。即买房需要多少数量的水果，卖房需要卖出多少数量的水果。<br>而债券市场的均衡是债券的价格的均衡，而均衡点的位置就是利率。<br>感觉利率就是债券的真实价值，和价格代表水果的真实价值一样。（中间绕了一层）<br>当债券价格高，就代表水果供给多，需求相对过多，会导致债券价格下跌（水果供给变少），利率下跌（水果价格下降）<br>当债券价格低，就代表水果供给少，需求相对过少，会导致债券价格上升（水果供给变多），利率上升（水果价格上升）<br>债券价格的高低，相当于水果的供给多少。（价格高代表水果供给多，那么利率下跌）<br>反过来：<br>利率低，代表水果价格低，水果供给多，即债券价格高。<br>利率高，代表水果价格高，说过供给少，即债券价格低。</p>
</li>
<li><p>上面是债券和利率的关系，使用债券的供给和需求来讨论利率（市场利率）的变化情况和变化关系）<br>下面是货币的供给和需求来说明货币和利率的关系：利用凯恩斯的流动性偏好理论来解释</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/04/nginx个人笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/04/nginx个人笔记/" itemprop="url">
                  nginx个人笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-04T00:19:56+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ls-gt-handler钩子"><a href="#ls-gt-handler钩子" class="headerlink" title="ls-&gt;handler钩子"></a>ls-&gt;handler钩子</h3><p>ls结构体代表的是一个监听结构体，它的handler成员会随着nginx在哪一层来解释tcp流有所不不同</p>
<ul>
<li><p>http流<br>如果作为http来解释tcp流的话，其<code>ls-&gt;handler</code>为<code>ngx_http_init_connection</code><br>(注：ls-&gt;handler的设置在解析http{}块的最后几步ngx_http_optimize_servers中设置的回调，包括创建ls结构体）.<br>每个listenfd都会有一个ls结构体，其ls-&gt;handler为其建立连接后初始化的钩子，即在accept后被调用，具体是在ngx_event_accept中.<br>每个lisenfd也会有一个c，rev，wev结构体与之对应，而其对应的rev的handler:rev-&gt;handler被设置为ngx_event_accept.这个过程在ngx_event_process_init中可以看到.<br>在epoll_wait的时候，由event_list[i].data.ptr指向了c，继而会找到rev、wev，然后待用rev-&gt;handler,这里就是ngx_event_accept了.<br>在ngx_event_accept中只是传递了ev结构体，那么如何找到了ls呢？答案就是ev-&gt;data会指向c，而在ngx_event_process_init中，每个listenfd对应的c的c-&gt;listening都会指向ls结构体，这样就找到了ls.<br>实际上，在ngx_event_accept中，新生产的c的c-&gt;listening也指向了被其accept的ls结构体.:)</p>
</li>
<li><p>stream流<br>对于四层流而言，在解析stream块时，ngx_stream_optimize_servers将ls-&gt;handler设置为乐ls-&gt;handler=ngx_stream_init_connection. </p>
</li>
</ul>
<h3 id="事件的小发现"><a href="#事件的小发现" class="headerlink" title="事件的小发现"></a>事件的小发现</h3><p>今天看了下框架层面的代码</p>
<ul>
<li>模块的init_process是在worker中执行的，所以是每个worker执行，而init_module是master的时候执行的，注意区分。</li>
<li>在Nginx中，连接c才有读写事件，c-&gt;rev/wev,请求没有这个概念，我们说读事件／写事件，都是说在该连接上发生的事件，而请求只是在连接之上的抽象，它没有读写事件的资格</li>
<li>在ngx_conf_parse中发现，cycle是main中的一个局部变量，同时注意区分cycle,cycle-&gt;conf_ctx(就是那个著名的void<em>**</em>),conf (ngx_conf_t*,经常看到的cf）。</li>
<li>所有的事件钩子的参数都只有一个ev，而ev的data字段会指向其c字段，而c字段的data字段会指向r字段，这样就把c、r都找到了.（这里注意空闲的c的data字段是指向下一个空闲的c的）</li>
<li>注意区分事件handler和IO-handler的区别：事件处理handler是ev-&gt;handler,而IO-handler是存在c上的c-&gt;read/write，c-&gt;read=ngx_unix_recv,c-&gt;write=ngx_uint_send等等。而在ev-&gt;handler中可以使用它们来做IO。<br>这中做法好棒，可扩展性强.</li>
</ul>
<h3 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h3><ul>
<li><p>最近写创建共享内存时候发现的,ngx_shared_memory_add,如果未赋值shm-&gt;init,shm-&gt;data,会导致-t检查不通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo ./nginx-1.6.2/obj/nginx -p `pwd` -c conf/nginx.conf -t</div><div class="line">nginx: the configuration of file /home/ke/test/web_server/nginx/try/conf/nginx.conf syntax is ok</div><div class="line">``` </div><div class="line">/*后面一句successfule居然就没有啦,加上后就可以了*/</div><div class="line">shm_zone-&gt;init=ngx_http_xxx_init_zone;</div><div class="line">shm_zone-&gt;data=shmctx;</div></pre></td></tr></table></figure>
</li>
<li><p>添加一种和event、http同等级的模块，写完后，发现配置指令错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sudo ./nginx-1.6.2/obj/nginx -p `pwd` -c conf/nginx.conf -t</div><div class="line">nginx:[emerg] &quot;xxx&quot; directive is not allowed here in /home/ke/test/web_server/nginx/try/conf/nginx.conf:17</div><div class="line">nginx:configuration file /home/ke/test/web_server/nginx/try/conf/nginx.conf test failed</div><div class="line"></div><div class="line">配置示例如下：</div><div class="line">events &#123;</div><div class="line">    worker_connection 1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line">mylevel &#123;</div><div class="line">    xxx;</div><div class="line">&#125;</div><div class="line">后来发现问题是block钩子没有解析完导致的，把ngx_xxx_block解析写完成即可</div></pre></td></tr></table></figure>
</li>
<li><p>纠正关于Nginx命令解析时候offset的作用的影响</p>
</li>
</ul>
<p>以前在写cmd时候，以为offsetof(xxx,xx) 写了之后，就会对最后调用set函数时的conf有影响，即已经帮你找到了最终需要操作的字段。<br>现在经过验证，其实offsetof字段没有参与conf计算，你需要根据offsetof来自己确定最终的字段。如下：</p>
<p><img src="/img/nginx个人笔记/1.png" alt=""></p>
<p><img src="/img/nginx个人笔记/2.png" alt=""></p>
<p>最后经过debug调试:</p>
<p><img src="/img/nginx个人笔记/3.png" alt=""></p>
<p>打印出来的conf都是同一个位置，即loc_conf结构体，而并没有去在帮你找到具体的字段，需要你自己根据offsetof来找。parse_conf函数也证明了这点,即在拿到conf的时候并没有offset的参与:</p>
<p><img src="/img/nginx个人笔记/4.png" alt=""></p>
<p>那么既然是这样，为何还要设置offsetof字段呢？反正可以通过conf来得到结构体，然后利用结构体就可以取得各个字段了。<br>其实，如果是自己写的set函数，这个offsetof是没有啥作用的，但是在采用预定义的那些set（如ngx_conf_set_flag_slot等），这时候就必须指定offsetof了，因为预定义的set使用了offsetof直接拿到具体的字段。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/Nginx中Set变量的“来龙去脉/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/Nginx中Set变量的“来龙去脉/" itemprop="url">
                  Nginx中Set变量的“来龙去脉
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T20:26:05+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>在配置文件中，经常会创建一个变量或者使用其它模块导出的内置变量。如果我们自己创建一个变量，那么需要用到set指令。由于变量使用的如此频繁，且加上各种if，rewrite的结合使用，往往使得实际运行效果会出现意想不到的结局，那么有必要对set指令进行分析。</p>
<h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><p>首先来看这样的一小段配置：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/1.png" alt=""></p>
<p>如上面的配置所示：在两个location块中配置了set命令，且配置的变量名字都是foo。<br>server1_test1 :   $foo    hello;<br>server1_test2 :   $foo     1;<br>                  $foo     2;<br>下面分别访问这两个loca块，查看其分别会输出什么？结果如下：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/2.png" alt=""></p>
<p>结果：访问server1_test1 echo出 hello<br>      访问server1_test2 echo出两个2.</p>
<p>猜想<br>1，既然set只定义了一个变量，那么按照编程语言中变量定义和赋值的逻辑，在server1_test2中的两次set，后一次的set把前一次的set覆盖了，即重写了foo的值。<br>2，既然对同一个变量会根据先后顺序重写，那么为何server1_test1中的foo没有被重写？是否是每个location中都会隔离开来？</p>
<h3 id="set后的内存布局"><a href="#set后的内存布局" class="headerlink" title="set后的内存布局"></a>set后的内存布局</h3><p>要正确解释上面的执行逻辑，需要清楚知道在配置set后，Nginx解析配置时的内存结构体布局。为此，从简单配置开始，以下面的配置代码为例，探索其内存布局。</p>
<h4 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h4><p><img src="/img/Nginx中Set变量的来龙去脉/3.png" alt=""></p>
<p>用上面一个简单的配置文件来探索其结构体的分配。在某个location层下面用set定义了一个变量foo，为其取值为hello。<br>(tips: 在Nginx中变量的值类型只有一种，即字符串类型，故后面的hello不加引号或加双引号都是可以正确解析的，但如果有空格，需要用引号）</p>
<h4 id="结构体分布"><a href="#结构体分布" class="headerlink" title="结构体分布"></a>结构体分布</h4><p>在Nginx中，变量的名和变量的值是分开存储的。 </p>
<h5 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h5><p>变量的名通过结构体ngx_http_variable_t 来表示，且都放入全局唯一的结构cmcf中的variable_key中的字段。如下图：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/4.png" alt=""></p>
<p>说明：<br>1，对于变量名的表示，Ngx中用了cmcf的两个字段数组来实现，一个是包含了Nginx内部和第三方模块定义过的变量，另一个包含在执行过程中Nginx要使用的变量。对于Set指令定义的变量，即定义又使用了，所以会加入到variables数组中。（对于一些内置变量如果出现在配置中，则解析时候也被加入到variables中）<br>2，直观认识：以上面的配置文件为例，被定义过的变量有76个，而被使用的变量（包括set命令的3个）只有8个。<br>我整理了使用的8个变量如下：<br>uid_resetserver,foo,proxy_host,remote_addr,remote_userrequesthttp_referhttp_user_agent,requesthttp_referhttp_user_agent,http_referhttp_user_agent,http_user_agent.<br>定义过的变量太多，这里不列出。</p>
<h5 id="变量值"><a href="#变量值" class="headerlink" title="变量值"></a>变量值</h5><p>变量的值的存放和set指令的位置有关，由于set指令是从属在ngx_http_rewrite_module这个模块的，因此需对这个模块定义的结构体有所了解。<br>在ngx_http_rewrite_module模块中，定义了一个loc类型的结构体，表示如下：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/5.png" alt=""></p>
<p>其中在codes字段会涉及到存放set变量值的相关操作。以上面的配置为例，那么解析后的值存放布局如下：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/6.png" alt=""></p>
<p>说明：<br>1，对于codes数组，实际上是一个字节流数组。<br>2，对于变量值的实现，采用了两个结构体val,vcode,其重要的两个子段为code字段，这是两个回调函数，会在变量解析完成后被回调。<br>3，连接变量名和变量值间的关键桥梁就是 vcode中的index字段。（关于如何从变量名找到变量值下面会有说明）<br>4 ，关于val的code回调是有“存入”的意味，vcode的code回调有“取出”的意味</p>
<h3 id="多个同名变量的结构布局"><a href="#多个同名变量的结构布局" class="headerlink" title="多个同名变量的结构布局"></a>多个同名变量的结构布局</h3><p>以开始的那份配置文件为例，来探索分布在不同location下的多个同名变量是如何布局的。</p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><img src="/img/Nginx中Set变量的来龙去脉/7.png" alt=""></p>
<h4 id="结构布局"><a href="#结构布局" class="headerlink" title="结构布局"></a>结构布局</h4><p><img src="/img/Nginx中Set变量的来龙去脉/8.png" alt=""></p>
<p>说明：<br>1，从上面可以看出,虽然出现了三个set，但由于只定义了一个变量foo，所以在全局结构cmcf中的有关变量名的结构体只会有一份。<br>2，在server1_test1结构体中，只有一次set，那么在ngx_http_rewrite_module模块中的rlcf结构体中只有一份关于变量值的结构实现。<br>而在server1_test2结构体中，有两次set，那么。。。。。。。。。。。。会有两份结构实现。</p>
<h3 id="变量解析后的初始化"><a href="#变量解析后的初始化" class="headerlink" title="变量解析后的初始化"></a>变量解析后的初始化</h3><p>如果刚开始解析完配置文件，那么变量的内存布局就如上面所示，但Nginx会对变量做进一步的初始化工作，比如上面变量结构体中的get_handler,set_handler,data等字段都没有赋值。其关键的函数为 ngx_http_variables_init_vars</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/9.png" alt=""></p>
<p>该函数的执行时机很值得注意：是在将http{}配置文件解析完成后来执行的。（后面的init_phases_handlers也很重要，关于11阶段的初始化）</p>
<h4 id="ngx-http-variables-init-var流程"><a href="#ngx-http-variables-init-var流程" class="headerlink" title="ngx_http_variables_init_var流程"></a>ngx_http_variables_init_var流程</h4><p>1,”使用过”的变量中字段没有初始化，这时候会从相应的“定义过”的变量中的字段赋值而来。<br>以上面的foo为例，“使用过”变量的结构体中的get_handler将设置为ngx_http_rewrite_var.，data设置为1（下标）等等。<br>2，检查在“使用过”变量中是否存在在“定义过”变量中找不到的变量，这样就会报错：变量未定义。<br>3，为”定义过“的变量建立hash表，同时释放”定义过“变量的指针。</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/10.png" alt=""></p>
<h4 id="经过变量初始化后的内存布局"><a href="#经过变量初始化后的内存布局" class="headerlink" title="经过变量初始化后的内存布局"></a>经过变量初始化后的内存布局</h4><p>经过ngx_http_variables_init_var的初始化，其“定义过”的变量从数组结构中转入到了hash表中，且将数组结构的指针置空了，同时完善了“使用过”的变量的各个字段。<br><img src="/img/Nginx中Set变量的来龙去脉/11.png" alt=""></p>
<p>说明：<br>1，对于hash的组织方式，我这边不太确定具体的结构是如何的，可能在图中画的有偏差。<br>2，将“定义过”变量的结构转为hash方式来存储</p>
<h3 id="请求与变量的关系"><a href="#请求与变量的关系" class="headerlink" title="请求与变量的关系"></a>请求与变量的关系</h3><h4 id="变量值的获取"><a href="#变量值的获取" class="headerlink" title="变量值的获取"></a>变量值的获取</h4><p>在请求刚刚被建立时，在ngx_http_init_request中初始化了r-&gt;variables变量：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/12.png" alt=""></p>
<p>为这个数组开辟的空间是“使用过”的变量的数量，元素类型为 ：ngx_http_variable_value_t (变量值结构体）</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/13.png" alt=""></p>
<p>len会保存值的字符串长度，data保存值的字符串数据。<br>填充r-&gt;variables数组的时机是在rewrite模块注册在rewrite阶段的钩子中：ngx_http_rewrite_handler(ngx_http_request_t*r) .<br>该钩子做的主要工作就是回调在rlcf结构体codes字符流数组中存放的回调函数val-&gt;code、vcode→code. （注意，每次set一此，都会对应一组val，vcode结构体）</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/14.png" alt=""></p>
<p>回调发生在while循环中，首先定位codes数组，然后取出其code函数，最后回调。<br>以最初配置为例，请求server1_test1：curl http:127.0.0.1:10330/server1_test1 .这样rlcf中的codes有一个{val，vcode},其回调分别为：ngx_http_script_value_code,ngx_http_set_val_code.<br>首先进入val→code: </p>
<p><img src="/img/Nginx中Set变量的来龙去脉/15.png" alt=""></p>
<p>即把变量值取出放在临时中间变量e→sp中。（注意sp也是ngx_http_variable_value_t类型）<br>该回调是取出变量<br>然后是vcode→code:</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/16.png" alt=""></p>
<p>即从临时变量e-&gt;sp中取出变量值,放入r-&gt;variables数组中，其下标为为vcode设置的下标，也即为该值对应的变量名在cmcf→variables数组中的下标。<br>该回调是存入变量</p>
<p>codes数组中的两个回调，将变量值放入了相应的r→variables槽位中。</p>
<p>注意：1，临时变量e在这其中充当了一个栈。<br>      2，其r-&gt;variable[xx].data为指针，指向的是e的字段，而e的存活期是和r一致的。（可参考e的生成）</p>
<h4 id="变量小结"><a href="#变量小结" class="headerlink" title="变量小结"></a>变量小结</h4><p>经过rewrite阶段后，已经取得了变量值，这里可以做个小结。（这里只是针对set命令生成的变量）</p>
<h5 id="r与变量"><a href="#r与变量" class="headerlink" title="r与变量"></a>r与变量</h5><p>从上面的解析中可以看出，每次请求到不同的location，其选择的rlcf都不同，那么其变量值也会不同</p>
<h5 id="重名变量赋值"><a href="#重名变量赋值" class="headerlink" title="重名变量赋值"></a>重名变量赋值</h5><p>对于出现在同一个location 下面的重名变量，由于codes中的回调函数是从上上往下来执行的，且重名变量的code-&gt;index也一样，那么当然在r→variales中取得的值会按照最后的codes的数据覆盖，这样解析了</p>
<h3 id="echo执行"><a href="#echo执行" class="headerlink" title="echo执行"></a>echo执行</h3><p>为了探索如何使用变量，这里用到echo指令。echo指令具有打印变量的功能，可以清晰看到变量是如何被获取值的（感谢春哥贡献这么好的模块：））<br>6.1 echo指令解析<br>当配置 echo $foo 指令被解析时：<br>1，通过查找cmcf→variables数组来找到该变量的index参数并保存，如果未找到，模块会自己在cmcf-&gt;variables中创建变量（相当于指令的副作用吧）并返回index，适用于先使用后定义的变量。<br>2，生成模拟回调引擎，该引擎在content阶段被echo挂入的钩子回调，主要是通过index参数从r→variables数组中获取到该location下面的值。ngx_http_script_compile<br>6.2 echo取出变量值<br>ngx_http_script_run函数根据在解析配置阶段保存的index，从r-&gt;variables中拿出变量值。</p>
<h3 id="使用案例小结"><a href="#使用案例小结" class="headerlink" title="使用案例小结"></a>使用案例小结</h3><h4 id="典型使用"><a href="#典型使用" class="headerlink" title="典型使用"></a>典型使用</h4><p><img src="/img/Nginx中Set变量的来龙去脉/17.png" alt=""></p>
<p>这是正常的使用，其流程为：<br>首先：<br>set指令将变量名放入cmcf-&gt;variables_keys-&gt;keys数组中，并放入cmcf-&gt;variables数组中，并给每个变量名指定一个index（为在cmcf→variables数组中的下标）<br>将变量值放入相应的rlcf结构体中的codes流式数组中的val结构体，同时紧接着val的vcode结构体中放入index下标。<br>同时，val和vcode中都设置了相应的回调引擎：ngx_http_script_value_code,ngx_http_script_set_val_code。<br>其次：<br>echo $xx 的配置，会在相应的结构体中生成模拟的codes流式数组，用来存放val和vcode。其中vcode中的index值根据$foo名字从cmcf→variables中来找到index下标。（存放在variables数组中的变量都是将要使用的变量）<br>模拟的val和vcode中的回调引擎的设置: ngx_http_script_copy_len_code,ngx_http_script_copy_val_code.<br>再次：请求r在rewrite阶段会回调rewrite模块挂入的钩子ngx_http_rewrite_handler，将会把rlcf中的codes数组中所有的变量值存入r→variables数组中<br>其下标为vcode的index值。<br>最后：echo模块在content阶段中，通过回调模拟引擎中设置的回调ngx_http_script_copy_val_code，加上其index，会从r→variables[]数组中找到相应的变量值。</p>
<h4 id="同名变量覆盖使用"><a href="#同名变量覆盖使用" class="headerlink" title="同名变量覆盖使用"></a>同名变量覆盖使用</h4><p><img src="/img/Nginx中Set变量的来龙去脉/18.png" alt=""></p>
<p>这种配置，会使得两个echo都输出2，其解析指令的流程和第一中情况相似，其不同点如下：<br>1，指令配置顺序不是执行顺序。<br>2，第一个set指令将foo变量名放入cmcf-&gt;variables中（先放入cmcf-&gt;variables_keys-&gt;key中），下标为1，且会在rlcf的codes流失数组中设置index为1。第一个echo创建的模拟引擎中将foo的下标也设置为1（从cmcf→variables中查找得到的）。<br>第二个set指令在执行时，发现cmcf-&gt;variables_keys-&gt;keys数组和cmcf-&gt;variables中已经有了foo，那么会直接返回下标1，然后在rlcf的codes数组中设置引擎的index也为1，第二个echo创建模拟引擎是从cmcf→variables中查找得到其下标，设置为1.<br>3，在填充r-&gt;variables时，由于rlcf中的两个index都为1，那么会后面的指令的值会覆盖前面的，即r→vairlabes[1]=“第二个codes数组中的值“。<br>4，在content阶段，执行echo的钩子，通过运行模拟引擎，得到变量的index均为1，那么从r-&gt;variables数组中得到的变量值都为r→variables[1]，即第二次set时候的变量值。</p>
<h4 id="变量先使用后定义的情况"><a href="#变量先使用后定义的情况" class="headerlink" title="变量先使用后定义的情况"></a>变量先使用后定义的情况</h4><p><img src="/img/Nginx中Set变量的来龙去脉/19.png" alt=""></p>
<p>在这种情况下，先配置foo，然后set该变量。这样也是合法的，可以输出其变量值。该流程的逻辑如下：<br>1，解析echo的时候，由于在cmcf-&gt;variables数组中查找失败，那么将会生成在cmcf-&gt;variables数组中生成一个元素，并且置下标为1（注意这里没有在cmcf→variables_keys→keys数组中生成元素，而set是两个地方都生成了的）。并且置模拟引擎中的index为1。<br>2，执行set指令，首先会在cmcf→variables_keys→keys数组中查找，发现没有（echo指令并没有在这里面存放），生成之，然后在cmcf→variables里面已经有了foo（echo存放的），这时候就直接返回其index为1。 填充rlcf-&gt;codes数组。<br>3， 在rewrite阶段填充r→varialbes .<br>4，在content阶段echo模块根据模拟引擎的index从r→varialbes中取出数据。</p>
<p>所以，这种“后定义先使用”的方式也是合法的。</p>
<h4 id="使用未定义变量"><a href="#使用未定义变量" class="headerlink" title="使用未定义变量"></a>使用未定义变量</h4><p><img src="/img/Nginx中Set变量的来龙去脉/20.png" alt=""></p>
<p>这种情况下，启动会报错，解析过程都通过不了。<br>1，解析echo时，由于在cmcf-&gt;variables中找不到，那么将会生成在cmcf→variables数组中生成一个元素，并且置下标为1（注意这里没有在cmcf→variables_keys→keys数组中生成元素，而set是两个地方都生成了的）。并且置模拟引擎中的index为1。<br>2，在最终变量合法性检查的函数ngx_http_init_vars中，会检查cmcf→variables中出现的变量是否在cmcf-&gt;variables_keys→keys中出现过，若没有，则会报错。</p>
<h4 id="跨location使用变量"><a href="#跨location使用变量" class="headerlink" title="跨location使用变量"></a>跨location使用变量</h4><p><img src="/img/Nginx中Set变量的来龙去脉/21.png" alt=""></p>
<p>大家可以首先猜一下：访问第二个location块会有什么结果：hello？还是报错？<br>结果：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/22.png" alt=""></p>
<p>能够顺利通过检查，结果为空。下面是解释。</p>
<p>1，由于在第一个location中由echo在cmcf-&gt;variables中生成了foo变量名元素，set在cmcf-&gt;varables_keys→keys中生成了foo变量元素，这样就再次使用foo时，会通过检查。<br>2，test2块中，echo指令会在模拟引擎中设置index为1（即从cmcf→variables中找到了foo变量名）<br>3，在rewrite阶段，由于其loc下的rlcf结构没有codes，故其r→variables[]数组没有数据，这样在content阶段，echo模块按照index为1去拿数据，就为空了。</p>
<h4 id="set小结"><a href="#set小结" class="headerlink" title="set小结"></a>set小结</h4><p>下面总结set指令和echo指令（echo指令这里代表使用变量的那一类指令）的流程图：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/23.png" alt=""></p>
<p>在set指令和普通的使用变量的指令（以echo为例）间最大的区别就是：set指令会同时在cmcf-&gt;variables_keys→keys数组和cmcf -&gt;variables中存放变量名，而echo指令只会在cmcf-&gt;variabesl数组中存入变量名。</p>
<h3 id="关于set变量的继承性"><a href="#关于set变量的继承性" class="headerlink" title="关于set变量的继承性"></a>关于set变量的继承性</h3><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p>在set指令中，与之相关的就是rlcf→codes这个流式数组。rewrite模块中，我们并没有发现rewrite模块会有继承的特性，即server块中的codes数组不会继承给location块中的codes数组，其merge函数如下：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/24.png" alt=""></p>
<p>可以看到，并没有关于codes数组的继承。这时我就在想，那么set变量如果配置在server层，那么location层应该是继承不到的，做了个小实验，其配置如下：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/25.png" alt=""></p>
<p>在server层配置了变量foo，然后在locaiton层中访问它，本以为会输出空：</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/26.png" alt=""></p>
<p>但事与愿违，它竟然表现出了继承的特点。这使得我很纳闷，不得不开始追踪源码。<br>最后发现了问题：</p>
<h4 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h4><p>1 rewrite模块的特殊地方在：它在server_rewrite阶段和rewrite阶段都注册了自己的钩子且是同一个钩子：ngx_http_rewrite_handler<br>2 而server_rewrite阶段的执行时机在find_config阶段之前，也就是说,在server_rewrite阶段，请求并没有找到自己正确的location块，而是复用的server块中的结构。</p>
<p>这样就解释了：<br>1 r→varaibles[]的赋值发生在ngx_http_rewrite_handler的while循环调用codes数组的钩子中。<br>2 在server_rewrite阶段执行的ngx_http_rewrite_handler将server块层的变量都赋值到了r→varaibles[]中，这样就到达了“貌似继承“的效果。<br>3 location层中codes数组仍然为空。（下图为其内存布局）</p>
<p><img src="/img/Nginx中Set变量的来龙去脉/27.png" alt=""></p>
<p>在server_rewrite阶段，使用的是server层的rlcf，自然r-&gt;varialbes[]就被赋值了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1 set变量并没有继承性，但通过在server_rewrite阶段和 rewrite阶段执行的同一个钩子，实现了继承的效果<br>2 如果在server层和location层都set了同一个变量，那么r-&gt;variables[]的某个元素会被重写，即覆盖掉。（这不是继承merge带来的效果，而是一个函数在两个不同时间点执行带来的效果）</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>1，rewrite指令对变量的使用<br>2，rewrite阶段的流转和r各个字段的变化</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/nginx中锁的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/nginx中锁的实现/" itemprop="url">
                  nginx中锁的实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T20:17:12+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>草稿版，后续整理</p>
<p>1 和nginx中自建内存池一样，共享内存也用slab来管理，减少系统调用次数<br>2 无阻塞锁和自旋锁的实现都建立在共享内存的基础上 </p>
<p>在锁结构ngx_shmtx_t中的lock指向了某处共享内存的地址，对这块地址的操作和赋值就代表对锁的争抢。<br>这里的赋值操作都是gcc中的原子变量操作 。 </p>
<p>无阻塞锁和自旋锁都是ngx_shmtx_t，只不过对于获取锁的方式不一样。（获取的意思是将该共享内存的某个地址的数据置位或者填入自己的workerpid，标明我成功抢锁）</p>
<p>无阻塞方式获取：获取不到，立即返回<br>自旋锁：获取不到，等待一会再去获取，但是这段时间不释放CPU，忙等，但让cpu进入省电模式（pause.(微笑). ）（自旋锁的设计就是为那些占据时间很短的锁而出现的）</p>
<p><img src="/img/nginx中锁的实现/1.png" alt=""><br>上面就是无阻塞锁，下面是自旋锁，红色方框中是原子操作。</p>
<p>1  ngx_atomic_t 这个类型是在前面加了volatile的，防止被优化，对其不能进行原子操作了。<br>另外，如果某个变量被定义为ngx_atomic_t，那么一半定义为指针，然后指向共享内存中，进行原子操作。<br>例子：<br> (void) ngx_atomic_fetch_add(ngx_stat_accepted, 1);<br> 这个就是对共享内存里的监控状态字段accetp进行操作</p>
<p><img src="/img/nginx中锁的实现/2.png" alt=""> </p>
<p>用gcc的潜入汇编进行原子操作<br>状态码的定义：</p>
<p><img src="/img/nginx中锁的实现/3.png" alt=""> </p>
<p>真实的赋值在共享内存中：</p>
<p><img src="/img/nginx中锁的实现/4.png" alt=""> </p>
<p>即都指向了共享内存中。</p>
<p>－－－－nginx中时间缓存的解析－－－－－</p>
<p>2  困惑在ngx_update_time中:</p>
<p><img src="/img/nginx中锁的实现/5.png" alt=""> </p>
<p>问题在于 ngx_time_lock我看了下，不是个在共享内存中的变量。。。。</p>
<p>哦，懂了，是每个worker都独自为战地管理自己的时间，每个worker都有自己的时间缓存，并不是所有worker共享一个时间缓存。（开始看了老半天，后来才发现时各个进程各自管理自己的时间缓存）</p>
<p><img src="/img/nginx中锁的实现/6.png" alt=""> </p>
<p>而代码里面把这个这么写，是为了后续的多线程池而考虑的。在没有开启多线程池的模式下，可以忽略。</p>
<p>另外原子变量的应用：只是为了确保在使用原子操作时候的连续性，对这个原子变量所处的位置（进程内还是共存中）没有限制的。</p>
<p>4 为何要进行时间缓存：<br>这就是时间缓存的原因：很多地方需要时间，但是不一定要十分精确，这样缓存时间<br>做到“及时”更新，减少系统调用。<br>比如要获取在1s中内要连续获取10000次时间，那么我可以每间隔500ms进行一次缓存，虽然时间精度不准，但是够用，而且只进行两次系统调用</p>
<p>下面截图：<br><img src="/img/nginx中锁的实现/7.png" alt=""> </p>
<p>另外时间slot也是一个设计很精妙的地方</p>
<p>5 和时间相关的：epoll_wait醒来有几种情况：1 socket事件发生，2 超时，3 被信号中断<br>其中第三种情况容易忽视：在nginx配置文件中，如果设置了ngx_timer_resolution,则会设置一个定时器，定时产生SIGARGM信号，此时epoll_wait中超时timer的参数为-1,表示永远不超时，此时由SIGARGM信号来定时<br>中断唤醒epoll（当没有socket时间发生时）。当然，如果没有配置ngx_timer_resolution，则依然会用红黑树定时器中的最小超时时间来作为timer</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/基于ngx-lua的分流系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/基于ngx-lua的分流系统设计/" itemprop="url">
                  基于ngx_lua的分流系统设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T20:05:29+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>为了在接入层面做到对请求精细化的控制和导流，需要在nginx上做分流的工作，解决包括但不限于几种需求，如版本上线，灰度发布、特殊用户，特殊版本等。其工作流程如下：</p>
<p><img src="/img/基于ngx_lua的分流系统设计/1.png" alt=""></p>
<p>在业务侧，可以根据需求将其业务节点划分为组，可以按照自己定制的策略来反馈给nginx，根据需求来导流相应分组。</p>
<h3 id="NGINX＋Lua实现"><a href="#NGINX＋Lua实现" class="headerlink" title="NGINX＋Lua实现"></a>NGINX＋Lua实现</h3><h4 id="方案预期"><a href="#方案预期" class="headerlink" title="方案预期"></a>方案预期</h4><p>在到达分流目的同时，需要有到达其它几个目的：<br>1 配置方便，兼容其它功能<br>如果某个服务需要接入分流系统，SRE可以清晰清楚且便捷的配置即可，不会影响其它的功能，不需要有其它冗余的操作或交流。</p>
<p>2 提供降级开关<br>响应业务需求，SRE或者业务需求发能够方便地选择开启或者关闭某个分流需求，甚至不需要对nginx做重启操作</p>
<p>3 即配即走，不重启NGINX<br>我们希望能够到达即配即走的效果，不重启NGINX。（当然接入分流系统时配置文件的变更，SRE需要重启）<br>（事实上如果业务接入了其它lua的功能，那么连配置都不用更改，直接走新的Lua框架即可生效）</p>
<p>4 系统轻巧，耦合度低<br>希望将系统做的足够轻巧，能够掌握整改分流过程和生效过程，方便及时排查问题，不影响其它业务。</p>
<p>5 高容错性<br>系统不应该对请求有伤害，包括系统不可用时、分流集群不合法时等意外情况下，都要保重请求的正常。</p>
<p>6 流量统计<br>能够从对分流情况有明确的感知和了解，包括每个分流集群的qps、响应时间等。</p>
<h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><h4 id="方案架构"><a href="#方案架构" class="headerlink" title="方案架构"></a>方案架构</h4><p>为了达到上面几个目的，构件了一套轻巧的系统。核心思想为表驱动的方式：以业务的appkey为索引，通过查表找出该业务需要分流的策略，将具体分流策略下放，加载策略进行分流。</p>
<p><img src="/img/基于ngx_lua的分流系统设计/2.png" alt=""></p>
<p>在请求来临时，取出appkey，查找分流数据，执行分流策略。每个不同的分流逻辑在不同的分流文件里面完成。<br>该表时刻处于变化中，从第三方存储中定时加载到nginx共享内存。其分流流程如下：</p>
<p><img src="/img/基于ngx_lua的分流系统设计/3.png" alt=""></p>
<p>分流数据的更新逻辑如下：<br>方案一：<br><img src="/img/基于ngx_lua的分流系统设计/4.png" alt=""></p>
<p>当管理机把更新的表推送到redis后，每个nginx会从redis里面定时拉取该表，缓存入nginx的共享内存。<br>该方案优势：<br>1 每个分流的Nginx都可以自己拉取，只要有定时拉取的逻辑<br>存在的问题：<br>1 单个worker拉取，需要patch tengine源码，担心会造成问题<br>2 每个nginx定时轮询，且定时时间短</p>
<p>方案二：<br><img src="/img/基于ngx_lua的分流系统设计/5.png" alt=""><br>通过http接口，在每次数据真正变更时候走http来更新每个分流nginx的内存，并将最新的一份数据存储在redis里面容灾。<br>优势：<br>1 不用定时器，即不需patch源码<br>2 在数据真正变动时进行更新，没有无谓轮询。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/https基础知识学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/https基础知识学习/" itemprop="url">
                  https基础知识学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T19:58:13+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SSL-TSL作用"><a href="#SSL-TSL作用" class="headerlink" title="SSL/TSL作用"></a>SSL/TSL作用</h3><p>使用传统的HTTP通信，内容都是明文传输，有下面的风险：<br>(1） 窃听：第三方可以获得通信内容<br>(2） 篡改：第三方可以修改通信内容<br>(3） 冒充：第三方可以冒充他人身份参与通信（会话劫持）<br>总结起来就是，由于是明文传输，第三方可以参与到会话中来干扰会话。<br>SSL/TSL协议可以解决上面的风险：<br>(1）所有信息都是加密传播（窃听）<br>(2） 具有校验机制，一旦被篡改，收到信息的一方会发现（篡改）<br>(3） 配备身份证书，防治被冒充。</p>
<h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>1 对称加密，又叫私钥加密、共享密钥加密，在加密解密时使用相同的密钥，或是两个key简单地相互推算的密钥。这个（组）密钥成为通信成员间的秘密。<br>明文&lt;－－－&gt;privatre key(密钥）&lt;－－－－&gt;密文<br>缺点：要求通信各方取得相同的密钥（私钥）（私钥＝＝密钥＝＝private key，和下面的公钥对应，对称加密中只有private key）<br>即如果1000个人进行加密通信使用对称加密协议，那么这个private key就需要在这1000人中共享，如果某个人的key被盗，那么整个加密信息都被破解。<br>常见对称加密算法：DES，AES，RC5<br>(个人观点：其实没有什么公钥私钥秘钥，都是一个key，只是这个key是否key让第三方知道，比如在对称加密中，这个key就不能让第三方法知道，那么就称之为privdata key，私钥或者密钥，而在非对称加密中（下面），某些key可以让第三方知道，那么就称该key为pulic key，即公钥）。</p>
<p>2 非对称加密,就是为了解决上面的问题：即一个人的key被盗，加密体系就被攻破了。非对称加密保证，即使一个人的密钥被盗，你发送给其他人的信息依然能保证不被破解。<br>首先，停止分享密钥，因为上面的bug就来自于共享一个key。<br>然后，每个人都生成一份钥匙对“public_key—private_kye“. 公钥可以任意让人知道，私钥自己保管。<br>比如这样：A生成自己的钥匙对public_key_a,private_key_a<br>      B生成自己的钥匙对public_key_b,private_key_b<br>那么AB之间交换public_key（key让别人知道），如果A向B发送信息，那么就用B的pulibc_key_b进行加密，发送给B，这个信息只有拥有private_key_b的B才能进行解密，其他人不能。同理B向A发送信息，也是按照这个套路。 这样既是中间人（第三方）获取了某段密文，由于没有该密文对应的相应密钥，也无能为力。</p>
<h3 id="TSL基本运行过程"><a href="#TSL基本运行过程" class="headerlink" title="TSL基本运行过程"></a>TSL基本运行过程</h3><p>SSL/TSL基本思路是采用非对称加密，即client向server索要公钥，然后用其加密，server端收到加密信息，用自己的私钥解密。（非对称加密，如RSA）<br>但是这里几个问题：</p>
<p>(1）client向server索要公钥时，如何保证公钥不被篡改？<br> 比如上面谈到的AB之间通信首先获取对方公钥，如果C冒充B，把C的公钥发送给A，如果A不知道，依然用这个公钥进行加密，那么C就可以破解。<br> 解决：将公钥放入证书，只要证书是可信的，公钥就是可信的。至于证书机制如何保证公钥的不被篡改，可以深入研究。（关键词：数字证书，数字签名，CA，公钥基础设置PKI）</p>
<p>(2) 非对称加密的效率很低，需要大量的计算，如何减少通信的耗时？<br>解决：每一次对话（session），client和server都商量生成一个会话密钥，(session key),用它来加密信息，由于会话密钥是对称加密，速度有保障。而回话密钥的生成过程用公钥来加密，防治第三方知道会话密钥）。</p>
<p>(生成回话密钥的过程就是握手的过程，在这期间有三个随机数被传输，其中第1个随机数用是client向server端传输（明文，此时还没得到server的公钥），第二个是server向client传输（明文，同时携带自己的公钥），第三个是client向server传输（用公钥加密，密文），这样的三个随机数用来生成会话密钥）</p>
<p>keyless：</p>
<p>其实从前面看到，整个过程中最重要的是通信双方协商好会话密钥，且server端的公钥和私钥都是为生成这个会话密钥而服务的，在后续阶段会话阶段并不会用到。那么这样可以用一种托管的玩法：<br>比如银行想把自己的业务托管给CDN厂商，提升自己网站的性能，但并不希望将私钥告知CDN。他可以这样玩：<br>客户在和CDN协商会话密钥时，CDN厂商将银行的公钥传递给客户，然后CDN将加密后的第三个随机数传递给银行（因为只有银行才能解开），银行揭开第三个随机数后传递给CDN，这样CDN就可以得出会话密钥了。<br>当然CDN和银行之间的通信是加密通道。</p>
<p>这就是cloudflare公司宣布的keyless服务：即使</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://segmentfault.com/a/1190000004461428（对称加密和非对称加密）" target="_blank" rel="external">https://segmentfault.com/a/1190000004461428（对称加密和非对称加密）</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html（session-key" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html（session-key</a> resumption）</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html（非对称加密）" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html（非对称加密）</a></p>
<p><a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/（keyless）" target="_blank" rel="external">https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/（keyless）</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/关于Nginx中worker进程的ID号/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/关于Nginx中worker进程的ID号/" itemprop="url">
                  关于Nginx中worker进程的ID号
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T19:44:21+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h4><p>在做基于ngx_lua的开发时，遇到一个问题，需要开启唯一的一个定时器来做定时更新任务，那么需要有一个且只能有一个worker来创建这个定时器，且在初始化worker进程的时候就应该启动这个定时器。起初是想用互斥锁lua-resty-lock来解决，后来发现很多麻烦（包括worker挂掉后的处理逻辑）。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1 在openresty中的一个接口ngx.worker.id()可以返回每个worker的ID号，即如果启动了16个进程，那么ID号就是从0-15，且任意一个worker挂掉后，master重新拉起来这个worker时，它的ID号不变（注意不是pid号，而是id号）。<br>2 这个特性用来做互斥最佳：确定哪个ID号的worker可以创建timer，且这个worker挂掉后，重新起来的worker由于ID号不变，依然会重新创建这个timer。所以在系统中始终都会保证一个且唯一的timer存在。<br>3  由于这个特性是NGINX1.9+内核才支持的，对于tengine暂时不支持，所以添加了少量的patch。下面解释这个特性的逻辑。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h4 id="worker启动"><a href="#worker启动" class="headerlink" title="worker启动"></a>worker启动</h4><p>首先是master启动各个worker：</p>
<p><img src="/img/关于Nginx中worker进程的ID号/1.png" alt=""></p>
<p>ngx_master_process_cycle是master来启动各个worker时执行的接口，其中核心的函数调用为ngx_start_worker_pocesses<br>ngx_start_worker_pocesses的各个参数：cycle为核心的数据结构，每个worker都会继承此结构（全局唯一），ccf→worker_processes为在配置文件中配置的进程数目，NGX_PROCESS_RESPAWN表示type（？）<br>下面跟随这个启动调用：</p>
<p><img src="/img/关于Nginx中worker进程的ID号/2.png" alt=""></p>
<p>根据进程数据，以此创建子进程.<br>fork调用发生在ngx_spawn_process中，其原型为：</p>
<p><img src="/img/关于Nginx中worker进程的ID号/3.png" alt=""></p>
<p>那么每个worker中的data参数即为该worker在创建时候的次序，即上面的 “i”，而参数proc则是worker进程的工作函数，即ngx_worker_process_cycle. </p>
<h4 id="worker占位"><a href="#worker占位" class="headerlink" title="worker占位"></a>worker占位</h4><p>master主进程需要全面掌空所有worker进程的动态，它用一个进程数组保存了各个worker进程的状态：</p>
<p><img src="/img/关于Nginx中worker进程的ID号/4.png" alt=""></p>
<p>master每创建一个worker都会把一个设置好的ngx_process_t结构变量放入ngx_processes中，进程表长度为1024（也即nginx中最多可以起1024个worker）</p>
<p><img src="/img/关于Nginx中worker进程的ID号/5.png" alt=""><br><img src="/img/关于Nginx中worker进程的ID号/6.png" alt=""><br>每个ngx_process_t元素相当于worker进程在nginx中的抽象<br>上面的ngx_spawn_proccess函数会在创建一个进程之前，首先在此数组中找到一个空位，然后完善相应字段，全局变量ngx_process_slot会记录此槽位。<br><img src="/img/关于Nginx中worker进程的ID号/7.png" alt=""></p>
<h4 id="worker工作进程"><a href="#worker工作进程" class="headerlink" title="worker工作进程"></a>worker工作进程</h4><p>在spawn中会fork出工作进程，并用ngx_start_worker_pocesses来开始worker的流程：</p>
<p><img src="/img/关于Nginx中worker进程的ID号/8.png" alt=""></p>
<p>注意1:其入口参数data即为启动时候的次序 “i”。<br>注意2:这里的data的保存会在master中保存在ngx_proccess_t数组中相应的位置：<br>在后面重新拉起相应进程时会用到）</p>
<p>而worker进程下面会就进入了ngx_start_worker_proccesses中，该函数也是worker进程的入口：<br><img src="/img/关于Nginx中worker进程的ID号/9.png" alt=""></p>
<p>所以，这里将data值赋值给了全局变量ngx_worker,而在ngx_lua中的ngx.worker.id()API导出的就是这个ngx_worker变量，也即每个worker启动时的次序。</p>
<h4 id="worker进程重启"><a href="#worker进程重启" class="headerlink" title="worker进程重启"></a>worker进程重启</h4><p>master如何保证当worker进程挂掉重启后，其传入的data仍然为开始时候的次序？</p>
<h5 id="CHILD信号处理"><a href="#CHILD信号处理" class="headerlink" title="CHILD信号处理"></a>CHILD信号处理</h5><p>在Nginx中，master和child通信是通过信号机制，当每个worker意外退出时，master会收到内核发送过来的CHLD信号，在Master中，所有的信号处理都是通过ngx_signal_handler来完成，它收到<br>CHLD信号后，会做如下处理：</p>
<p><img src="/img/关于Nginx中worker进程的ID号/10.png" alt=""></p>
<p>1，将全局信号标识量 ngx_reap 置位<br>2，通过ngx_process_get_status将相应的退出进程的数组元素ngx_proccess_t结构体中的exited字段置位</p>
<p><img src="/img/关于Nginx中worker进程的ID号/11.png" alt=""></p>
<p>通过waitpid获取退出进程的pid号，然后一一从ngx_proccess中比对。</p>
<h4 id="重新拉起进程"><a href="#重新拉起进程" class="headerlink" title="重新拉起进程"></a>重新拉起进程</h4><p>当master收到任何信号（包括CHILD信号），会从sigsupend的阻塞调用中返回，然后检查各个各个信号标识位：</p>
<p><img src="/img/关于Nginx中worker进程的ID号/12.png" alt=""></p>
<p>这里， 当ngx_reap置位后，会进入重新拉起worker进程的函数：ngx_reap_child</p>
<p><img src="/img/关于Nginx中worker进程的ID号/13.png" alt=""></p>
<p>检查进程数组，查看是否exited置位，表示需要重启，然后调用ngx_spawn_proccess启动新的worker：注意，这里传入的data是原先存放在ngx_procces数组相应的data。</p>
<p>所以，每次重启时，传入的data都是第一次按顺序启动的次序 i。这个次序不会变化。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Nginx中master管理worker进程的机制很值得学习，其通信方式也很优雅。此外，worker进程间的通信是采用socketpair机制（相当于双向管道）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/Ngx-lua一键截流系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/Ngx-lua一键截流系统/" itemprop="url">
                  Ngx_lua一键截流系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T19:23:45+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于某些服务的流量过大，为保护其后端服务，需要在接入层Nginx对某些服务流量进行截流。本系统可以提供按照百分比对指定域名的制定URI进行截流的功能</p>
<h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>管理员可以轻松在管理界面进行配置，接口界面大致如下</p>
<p><img src="/img/Ngx_lua一键截流系统/1.png" alt=""></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>采用nginx＋Lua的实现整个系统的截流功能，大致架构图如下：</p>
<p><img src="/img/Ngx_lua一键截流系统/2.png" alt=""></p>
<p>管理员在界面上写入数据，管理端服务会将数据放入redis集群，各个nginx节点，会定时从redis集群拉取截流数据。</p>
<h3 id="服务接入"><a href="#服务接入" class="headerlink" title="服务接入"></a>服务接入</h3><p>为了对达到快速方便的截流目的，默认是每个服务都接入截流系统，而不需要进行nginx配置文件的修改。</p>
<p>access_by_lua_file    “/etc/nginx/hlb-lua/access_lua/online_access.lua”;                （1）<br>server {</p>
<pre><code>server_name        server1;
</code></pre><p>}<br>server {<br>    server_name        server2;<br>}<br>server {</p>
<pre><code>server_name        server3;
</code></pre><p>}</p>
<p>server {<br>    server_name        server4;<br>}</p>
<p>这样能够到达全自动化的截流：<br>1 不需要在每个服务配置中做添加任何字段，也就意味着完全不用reload Nginx<br>2 针对某个服务下的某个路径进行截流，只需在管理端界面上输入数据即可完成</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>由于默认所有流量经过截流检测系统，需要比较造成的性能影响。计算截流逻辑的耗时。每组数据共采集5000条请求的日志，用ab实现压测，计算其在截流逻辑处的平均耗时。共测试10组数据</p>
<p><img src="/img/Ngx_lua一键截流系统/3.png" alt=""></p>
<p>由压测结果来看，截流逻辑耗时稳定在20us以下。</p>
<h3 id="灾难测试"><a href="#灾难测试" class="headerlink" title="灾难测试"></a>灾难测试</h3><p>截流系统依赖redis集群，考虑到集群的挂掉后对整改系统的影响，需要进行灾难测试。灾难测试分为两部分，分别是对管理端的影响和对Nginx节点的影响。<br>说明：由于所有截流数据缓存在集群的一个分片上，故灾难测试在该分片上进行。下面说的分片特指存放截流数据的分片</p>
<p><img src="/img/Ngx_lua一键截流系统/4.png" alt=""><br>结论：从结论看出，截流系统对于redis集群的故障能够做到有损提供服务，做到高可用。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="设置-修改）降级策略"><a href="#设置-修改）降级策略" class="headerlink" title="设置(修改）降级策略"></a>设置(修改）降级策略</h4><p>curl  www.admin.com/degrade/admin/?action=set -d ‘{“deg_servername”:”xx”,”deg_location”:”yy”,”deg_percent”:”100”}’</p>
<h4 id="删除降级策略"><a href="#删除降级策略" class="headerlink" title="删除降级策略"></a>删除降级策略</h4><p>curl www.admin.com/degrade/admin/?action=del -d ‘{“deg_servername”:”xx”,”deg_location”:”yy”}’</p>
<h4 id="查看查看降级策略"><a href="#查看查看降级策略" class="headerlink" title="查看查看降级策略"></a>查看查看降级策略</h4><p>curl www.admin.com/degrade/admin/?action=get -d ‘{“deg_servername”:”xx”,”deg_location”:”yy”}’</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/redis集群及ngx-lua接入方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/redis集群及ngx-lua接入方案/" itemprop="url">
                  redis集群及ngx_lua接入方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T18:11:01+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>精细化分流和降级的项目依赖redis存放分流和降级规则，为了保证redis的高可用，需避免其单点故障和数据丢失。整个系统的架构图如下：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/1.png" alt=""> </p>
<p>在管理端，通过多个管理实例来避免管理端的单点问题，将策略规则写入redis。在业务端，多个Nginx代理从redis中读出策略规则并缓存在本地的lua缓存中，结合用户请求，最终将其分流到不同的上游集群。</p>
<h3 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h3><p>将管理机和业务机如何正确接入redis集群是该项目考虑的问题。<br>1 当某个redis挂掉后，其上面的数据需要有备份，不能丢失。<br>2 整个redis集群须提供对外统一的访问接口。<br>为此考虑了以下几种解决方案：<br>1 主从模式<br>2 代理模式<br>3 集群模式</p>
<h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p>若用redis主从模式，其接入架构图可以为这样：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/2.png" alt=""> </p>
<p>1 在所有redis中有一个主库，其余均为从库，所有从库始终保持和主库数据同步。<br>2 所有的管理机均将策略写入主库，各个业务机将从各自的从库中读人。可以将从库于业务机部署在同一主机提高读取速度。<br>该方案的特点：<br>1 实现简单。redis主从关系设置方便，且有现成的接入单个redis的lua接口。<br>2 容灾性差。所有管理机都依赖于唯一的主库，造成单点问题（虽说系统依然可以正常处理业务），且业务机访问单个redis从库，也造成单点问题。<br>3 。。。</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>为了让多个redis对外提供统一的访问接口，尝试采用redis的代理服务。根据调研，目前业界有两种成熟的解决方案：twemproxy和codis。其架构图如下：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/3.png" alt=""> </p>
<p>通过代理，所有接入redis的请求都由代理来处理。<br>该方案的特点：<br>1 统一接口。代理对外提供了所有访问的统一接口，且可以兼容访问单个redis实例的lua接口<br>2 容灾较差。代理将数据写入或从redis集群中读出是采用分片的方式，从中选择某个redis来进行写或读。<br>如果某个redis挂了，其上面的数据依然会丢失。<br>针对2进行的改进是：对每个redis做主备，其架构如下</p>
<p><img src="/img/redis集群及ngx-lua接入方案/4.png" alt=""> </p>
<p>这样虽然保证了数据不丢失，但主库挂掉时，从库需要手动升级为主库，运维麻烦。</p>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><p>集群模式是redis在3.0后的分布式解决方案，可以很好地满足上面的两个要求：1 对外提供统一接口 2 数据一致性且不丢失。其接入架构图如下：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/5.png" alt=""> </p>
<p>集群中的所有redis都互相传递消息，且按照分片的方式进行存储数据。在本节介绍redis集群的部署方式后，在下一节介绍redis集群原理。</p>
<h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p>1 运行多个处于集群模式的redis实例<br>这里以6个为例。要使redis处于集群模式，需在配置文件里面添加：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/6.png" alt=""> </p>
<p>cluster-enabled表示是否以集群模式运行。其它字段意义可参考官网：<a href="http://redis.io/topics/cluster-tutorial" target="_blank" rel="external">http://redis.io/topics/cluster-tutorial</a></p>
<p>然后运行6个实例</p>
<p><img src="/img/redis集群及ngx-lua接入方案/7.png" alt=""> </p>
<p>其客户端监听端口以此为6380,6381,6382,6383,6384,6385。</p>
<p>2 安装依赖</p>
<p>上面的6个实例虽然处于集群模式，但是各自为战，并没有构成真正意义上的集群，为此需要将其构成集群。<br>在redis包中有将redis实例构成集群的管理包，但运行其管理包需要安装依赖环境，包括ruby，gem等</p>
<p><img src="/img/redis集群及ngx-lua接入方案/8.png" alt=""><br><img src="/img/redis集群及ngx-lua接入方案/9.png" alt=""> </p>
<p>3 构成集群</p>
<p><img src="/img/redis集群及ngx-lua接入方案/10.png" alt=""> </p>
<p>其中redis-trib.rb是构成集群的命令，create表示创建集群，–replicas 1表示集群中的每个主节点都将附带一个从节点。</p>
<p>4 安装完成</p>
<p><img src="/img/redis集群及ngx-lua接入方案/11.png" alt=""> </p>
<p>在集群中的6个节点中有3个主节点是负责真正写入和读出数据的，三个从节点将为其主节点备份，并在必要自动时候升级为主节点（没错，是自动升级，下一节会介绍其原理）</p>
<p><img src="/img/redis集群及ngx-lua接入方案/12.png" alt=""> </p>
<p>PS：<br>1 红色的为主节点，该集群也就表示由这三个主节点构成，其从节点只是为其备份数据，并不参与集群的数据的读写。<br>2 每个节点（包括从节点）都会感知集群中的每个节点的状态，且每个主节点都可以设置多个从节点。<br>3 主节点间的数据不冗余（即每个主节点间的数据都不是备份关系），而是经过分片处理数据。每个节点处理一部分“槽位”，redis集群方案共设置了16384个槽位。</p>
<h3 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>开始时，集群中的每个节点都是单个的集群，它们之间通过“握手”来构建整个系统集群，以上面的三个主节点组成的系统为例，构建集群的过程如下：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/13.png" alt=""> </p>
<p>首先6380节点和6381节点相会握手成功后，其会构件为一个集群，然后6381和6382握手成功后，所以的节点都加入了同一个集群。<br>在集群中的每个节点和在普通模式下运行的节点所代表的数据结构不同：clusterNode.</p>
<p><img src="/img/redis集群及ngx-lua接入方案/14.png" alt=""> </p>
<p>每个节点中都有感知集群中其它节点的信息。</p>
<h4 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h4><p>Redis集群是通过分片方式来保存数据的：整个集群的实现一共分为16384个槽（slot），这些槽在空间上组成环状。集群中的每个KV对都属于这16384个槽中的一个，且每个集群中的主节点可以处理0个或者多个槽，每个槽只属于一个主节点。<br>当16384个槽都被处理时，我们称集群处于上线状态（OK），可以通过每个主节点的clusterstatus结构体的state来标示。否则，任意一个槽没有被集群节点覆盖到，那么集群将处于线下状态（Fail）。<br>处于上线状态的集群中的每个主节点都感知每一个槽分别被哪个主节点处理的：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/15.png" alt=""> </p>
<p>如上所示：槽0－5000被节点6380处理，5001-10000被节点6381处理，10000-16383被节点6382处理。<br>这样每个节点都能迅速掌握哪个槽被哪个节点处理。</p>
<h4 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h4><p>当集群接受到redis命令时，首先计算该键值对应的槽位，然后判断该槽位是否被当前节点所处理，所是，则直接处理，否则将返回MOVED错误给客户端，客户端会通过MOVED错误的信息转向正确的主节点进行处理。其答大体步骤如下：</p>
<p><img src="/img/redis集群及ngx-lua接入方案/16.png" alt=""> </p>
<p>PS<br>1 键值与槽位的关系：<br>通过键值来计算槽位：CRC16(key)&amp;16383 。即先计算键值的CRC16校验和，然后得出一个介于0～16383间的整数做为key的槽位。<br>2 MOVED错误只有支持集群模式的客户段才能够正确处理（继续访问正确的主节点），否则将打印错误。</p>
<h4 id="复制故障转移"><a href="#复制故障转移" class="headerlink" title="复制故障转移"></a>复制故障转移</h4><p>如果集群中只包含主节点，那就大大降低了它的高可靠性，一般集群中的主节点都会有从节点。从节点主要用于在相应的主节点发生故障后代替成为主节点，实现故障转移，达到高可靠的特点。而这个过程在集群中是全部自动完成的。<br>1 集群中的每个主节点都感知各个主节点的从节点。<br>2 若集群中超半数的主节点认为某个主节点故障，则该主节点被下线。<br>3 某个主节点被下线的消息会被广播到所有节点（包括从节点）<br>4 当从节点（们）发现自己的主已经被判定为下线，那么这些从节点会向各个主节点发送选举请求，请求各个主节点支持自己成为主节点。<br>4 只有每个主节点有投票选举权，且只有一票。<br>5 若某个从节点已经得到过半主节点的投票，那么会将自己升级为主节点，同时接管原来主节点所处理的槽位，并向集群广播自己被选举成功的消息。</p>
<h3 id="接入细节"><a href="#接入细节" class="headerlink" title="接入细节"></a>接入细节</h3><p>想让上面的Redis集群接入到分流和降级系统中，需要有专门的Lua接口来接入redis集群。根据支持集群模式的C客户端和支持普通模式lua接口，可以构造支持集群模式的lua接口。</p>
<p>推荐：<a href="https://github.com/cuiweixie/lua-resty-redis-cluster" target="_blank" rel="external">https://github.com/cuiweixie/lua-resty-redis-cluster</a><br>PS:这个客户端有少许bug:<br>1 需要把local关键字加在redis实例前面，参考其PR<br>2 在高流量情况下，由于超时重试机制，导致一个请求创建了最多18个redis实例和超时timer，把LUA虚拟栈跑爆了，这个需要改造下</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/Nginx的网络模型-演变/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fantaotao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person1.PNG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/Nginx的网络模型-演变/" itemprop="url">
                  Nginx的网络模型 演变 
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T17:53:20+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Nginx的高性能得益于其优秀的网络架构模型。为了充分发挥多核CPU的优势，让每个进程都“亲缘”一个CPU，减少上下文切换带来的损耗，同时也需要解决多个进程监听同一个端口带来的各种问题，本文将简要描述下Nginx的网络架构的演变过程。</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="模型一"><a href="#模型一" class="headerlink" title="模型一"></a>模型一</h4><p>Nginx是单主(master)多从(worker)模式的进程架构，Master进程在解析配置文件的时候，对于每个监听的端口，将创建一个监听socket套接字，为了描述，这里假设在配置文件中开启了80和443两个端口。其网络模型如下：</p>
<p><img src="/img/Nginx的网络模型-演变/1.png" alt=""></p>
<p>在解析完配置文件后，master进程开始创建子进程，这些子进程会进程master的资源，当然包括套接字等，如果开启4个worker，则其网络模型如下：</p>
<p><img src="/img/Nginx的网络模型-演变/2.png" alt=""></p>
<p>这时候，如果有请求来临，内核会唤醒所有的进程，这就是惊群现象。（先不谈Linux内核是否解决了惊群现象，Nginx作为一个跨平台的服务，必须从自身解决这个问题）<br>传统的网络服务（如apache等）会采用每个请求分派一个线程来处理，而Nginx采用的IO多路复用机制（有时候也叫做事件驱动），如在Linux平台的epoll，BSD平台的kqueue等，配合非阻塞的soket API，充分利用了CPU，提升了网络服务质量。下面会以Linux平台下的epoll为例，说明Nginx是如何解决惊群问题的。</p>
<p>1 各个worker进程会创建自己的epoll句柄（不包括master）<br>2 接着会判读，管理员是否开启了惊群锁且worker进程的数量大于1。<br>   a,惊群锁默认是关闭的，如果管理员显示开启了accept_mutux off,则会禁用，Nginx就不会解决惊群问题。<br>   b,如果worker的进程数量小于2，那么不存在惊群问题，Nginx也会不解决惊群问题。</p>
<p>3 如果惊群生效，则每个worker首先不会去把监听套接字描述符加入自己的epoll系统，而是先去抢一把自旋锁，即对所有监听套接字的“控制权”。</p>
<p>4 抢到锁的worker进程，会将所有的监听套接字都加入自己的epoll中，而没有抢到worker会首先删除自己epoll中监听的监听套接字（如果有的话）。这样当有新请求来到时，只会有一个worker被唤醒，从而解决了惊群的问题。</p>
<p>其流程图大约如下：</p>
<p><img src="/img/Nginx的网络模型-演变/3.png" alt=""></p>
<p>小结：<br>1，在请求量不是特别大的情况下，Nginx这种解决惊群现象的手段提升了网络服务质量，避免多个进程无谓的被“唤醒”去accept请求失败而导致的损耗。<br>2，然后现在在很多情况下证明：当并发请求量过大时，这种依靠抢锁机制解决惊群的手段，会导致处理请求的效率下降，所以现在较多的建议是关闭accept_mutux锁，让Nginx不解决惊群。 </p>
<h4 id="模型二"><a href="#模型二" class="headerlink" title="模型二"></a>模型二</h4><p>在第一种模型下，通过抢锁来保障每次新请求到来时都只会有一个worker去执行accept，避免其它worker的无谓消耗。这种情况在高并发场景下受到了质疑，事实上，在高并发情况下，关闭惊群锁而不让Nginx处理“惊群”反而会提升处理效率。下面举一个例子说明：</p>
<p>试想，有一群小鸡，你撒谷粒给这群鸡吃。<br>a，一粒粒撒的时候，如果不加处理，每个鸡都会跳起来，但最终只有一只鸡能够吃到这粒米。<br>所以在一粒粒撒的时候，需要有锁，不能让每个鸡都跳起来，这样浪费它们的精力，必须要让它们遵守秩序，一个个来（加锁）</p>
<p>b，然而，如果你撒了一大把谷粒，这时候还让它们一个个来，这样是很不合理的，所以，在撒大把谷粒的情况下，这些鸡全部跳起来抢食才是科学的，这样才能更加快速地消耗掉这些谷粒。（不加锁）。<br>上面的小鸡就代表worker进程，谷粒代表高并发的请求，虽然比喻有些粗糙，但也能够说明问题。</p>
<p>所以，在高并发场景下，关闭惊群锁，每个worker都把所有的监听套接字加入到自己的epoll中去，让它们都试图去accept新的请求，这样做能够提升处理请求的效率。<br>而且，从高版本的Nginx开始，惊群锁也默认置为了关闭状态。<br>官方对此作了压力测试的对比，具体可见如下：<a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="external">https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/</a></p>
<p><img src="/img/Nginx的网络模型-演变/4.png" alt=""><br>(先忽略reuseport，比对default和accept_mutux off的两种情况）</p>
<h4 id="模型三"><a href="#模型三" class="headerlink" title="模型三"></a>模型三</h4><p>在Nginx1.9.1版本中，引入了新的socket网络选项，SO_REUSEPORT.<br>首先解释下这个选项：当socket设置了这个选项，可以让多个设置了这个选项的socket绑定和监听同一个端口（准确滴说是一个ip:port对）</p>
<p>1 default时候的网络模型：</p>
<p><img src="/img/Nginx的网络模型-演变/2.png" alt=""></p>
<p>在原始模型中，所有的worker通过master的fork调用，都公用一个socket来监听80端口(或其它端口）</p>
<p>如果开启SO_REUSEPORT特性，如下：</p>
<p>server {<br>    listen 80 reuseport;<br>    server_name  localhost;<br>                      ..<br>}// reuseport是listen指令后的选项。这和Tengine实现的在event块中的开启这个选项有所不一样。</p>
<p>则master在解析配置文件的时候创建监听套接字会有不同的动作：<br>它会按照worker的数目 n,对于每个ip:port对，都会克隆出多个监听socket，如下：（以4个worker为例）</p>
<p><img src="/img/Nginx的网络模型-演变/5.png" alt=""></p>
<p>可以看到，对于同一个端口，master建立了4个监听套接字，这四个监听套接字都bind到80端口。（需要注意的是，如果套接字不设置SO_REUSEPORT属性，那么当多个套接字bind到同一个端口时，会报错失败。当然这里每个套接字都设置了SO_REUSEPORT属性）</p>
<p>然后经过fork出worker进程：</p>
<p><img src="/img/Nginx的网络模型-演变/6.png" alt=""></p>
<p>然后，每个worker会根据自己的ID顺序号，将“属于自己”的监听套接字加入到自己的epoll中。（这段是翻看源码才能获知的，一开始怎么都想不明白～～）<br>以监听80端口的那四个套接字来说，worker1进程只会把套接字1加入自己的epoll中。如下图所示：</p>
<p><img src="/img/Nginx的网络模型-演变/7.png" alt=""></p>
<p>这样，每个worker都再也不用去抢监听锁讲监听套接字加入自己的epoll系统中了，现在每个worker的epoll中始终都有着属于自己的监听套接字。可以对比一下：</p>
<p><img src="/img/Nginx的网络模型-演变/8.png" alt=""></p>
<p>注意：在这种模式下，若某个端口有请求到来，是内核来决定将请求分发到那个监听套接字上，而且这种分发一般都是较为均衡的。</p>
<p>再来比对一下官方的测试数据：</p>
<p><img src="/img/Nginx的网络模型-演变/4.png" alt=""></p>
<p>其QPS和平均延时以及延时标准差都明显降低了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1 第一种默认的抢锁模式：<br>在大多数请求量适中的环境中都表现很优秀，而且从Nginx内部做到了解决惊群问题，具有跨平台的优势。而且由于解决了惊群问题，极大降低了CPU的负荷。</p>
<p>2 第二种“惊群”模式：<br>在第二种模式下，Nginx任由“惊群”现象的产生，让每个worker都尽自己的力量去抢到更多的请求。第二种模式在高并发场景下非常有效，但由于每次请求都会让所有worker去争抢请求，必然增大了CPU的负荷。</p>
<p>3 第三种reuseport模式：<br>在这种情况下，每个worker都有”专属于“自己的监听套接字，不用去挣抢锁，完全由内核将请求分发到各个套接字上面，做到了高效且降低CPU的负荷的特定。</p>
<p>下面是官方的对比：</p>
<p><img src="/img/Nginx的网络模型-演变/9.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/person1.PNG"
               alt="fantaotao" />
          <p class="site-author-name" itemprop="name">fantaotao</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fantaotao</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
