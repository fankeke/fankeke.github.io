<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="《红与黑》">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="《红与黑》">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">
<meta name="twitter:description" content="《红与黑》">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>个人博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">长生不老</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/源码剖析NGINX中的限速模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/源码剖析NGINX中的限速模块/" class="post-title-link" itemprop="url">源码剖析NGINX中的限速模块</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 22:12:23 / 修改时间：21:44:19" itemprop="dateCreated datePublished" datetime="2019-09-30T22:12:23+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在nginx中，有两个常用的限速模块 limit_conn 与limit_req，他们两者使用的场景各异，下面试图从源码视角来分析这两个模块的实现。这两个限速模块是典型的使用共享内存的模块，在分析这两个模块的过程中，顺便可以学习nginx是如何使用共享内存。</p>
<h3 id="1-实现方式"><a href="#1-实现方式" class="headerlink" title="1 实现方式"></a>1 实现方式</h3><p>两个模块都是在preaccess阶段插入的handler钩子，每个请求来时都会经过handler处理一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">limit_req</span><br><span class="line"></span><br><span class="line">h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers);</span><br><span class="line">if (h == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">*h = ngx_http_limit_req_handler;</span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line">limit_conn</span><br><span class="line"></span><br><span class="line">h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers);</span><br><span class="line">if (h == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">*h = ngx_http_limit_zone_handler;</span><br></pre></td></tr></table></figure>

<h3 id="2-配置解析"><a href="#2-配置解析" class="headerlink" title="2 配置解析"></a>2 配置解析</h3><p>首先是共享内存的定义，由于两个模块都在配置上都相似，下面以limit_req的配置为切入点，观察配置与源码的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone  $binaray_remote_addr zone=one:10m rate=10r/s;</span><br></pre></td></tr></table></figure>

<p>这一行定义了一块共享内存，其中key为ip地址(一般key都为变量方式），大小为10m，名称为one，在limit_req场景下限速为每秒允许10个key。注意这写属性都是共享内存的属性，与location以及请求都没有关系。</p>
<p>关键成员解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_limit_req_ctx_t));</span><br><span class="line">if (ctx == NULL) &#123;</span><br><span class="line">    return NGX_CONF_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;index = ngx_http_get_variable_index(cf, &amp;value[i]);</span><br><span class="line">if (ctx-&gt;index == NGX_ERROR) &#123;</span><br><span class="line">    return NGX_CONF_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;var = value[i];</span><br></pre></td></tr></table></figure>

<p>这里将变量的index存放在ctx上: ctx-&gt;index = ngx_http_get_variable_index(cf, &amp;value[i]);</p>
<p>nginx中常见这种写法：如果需要使用某个变量，则将该变量的index存放在结构体中，但这里需要注意的是，ctx这个名称一般都是与请求粒度相关的，请求销毁了，ctx也将销毁，但这里将ctx存放在了全局空间，申请在ctx=palloc(cf-&gt;pool,xxx)上， 这似乎不太符合命名规范。个人认为最好取名为zone_ctx, 即共享内存的上下文属性。</p>
<p>另外，由于这些成员没有存放在xlcf等location相关的结构体中，在后续使用的时候如何找到这里的ctx呢？答案是通过共享内存shm。由于ctx是和某个shm强相关，理所当然需要和相应的shm bind在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shm_zone = ngx_shared_memory_add(cf, &amp;name, size,</span><br><span class="line">                                     &amp;ngx_http_limit_req_module);</span><br><span class="line">shm_zone-&gt;init = ngx_http_limit_req_init_zone;</span><br><span class="line">shm_zone-&gt;data = ctx;</span><br></pre></td></tr></table></figure>

<p>这里shm_zone的data将其联系在一起。那么问题是，如果找到某个指定的shm？是通过共享内存的名称即可。<br><code>ngx_shared_memory_add(cf, &amp;name, 0, &amp;ngx_http_limit_req_module)</code>即可找到相应的shm。</p>
<p>而后续如果要使用shm，那么肯定需要提供name来找到，这样就将各个变量的衔接打通了。</p>
<h3 id="3-shm初始化与使用"><a href="#3-shm初始化与使用" class="headerlink" title="3 shm初始化与使用"></a>3 shm初始化与使用</h3><p>上面只是定义了shm的各个属性，没有具体将shm初始化以及组织，而初始化由各个使用模块自定义。下面以limit_req模块对shm的初始化为例进行分析：</p>
<p>初始化的钩子是<code>ngx_http_limit_req_init_zone</code><br>整个初始化的过程实际体现在如何给相关ctx赋值(前面提到的zone_ctx),来具体看下ctx的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_http_limit_req_shctx_t  *sh;</span><br><span class="line">    ngx_slab_pool_t             *shpool;</span><br><span class="line">    /* integer value, 1 corresponds to 0.001 r/s */</span><br><span class="line">    ngx_uint_t                   rate;</span><br><span class="line">    ngx_int_t                    index;</span><br><span class="line">    ngx_str_t                    var;</span><br><span class="line">&#125; ngx_http_limit_req_ctx_t;</span><br></pre></td></tr></table></figure>

<p>在申请shm的时候，rate、index、var等值已经被赋值过了，这里shpool是通过slab机制来使用shm的内存空间，是框架相关的机制，可以暂时不用关心(只需要知道使用slab机制可以高效地使用shm），后续对shm的内存分配都是通过ctx-&gt;shpool,不会直接在shm中分配，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx-&gt;sh = ngx_slab_alloc(ctx-&gt;shpool, sizeof(ngx_http_limit_req_shctx_t));</span><br><span class="line">if (ctx-&gt;sh == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么具体的组织细节体现在对sh的赋值上，这也是每片内存所独有的组织方式，看下sh的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ypedef struct &#123;</span><br><span class="line">    ngx_rbtree_t                  rbtree;</span><br><span class="line">    ngx_rbtree_node_t             sentinel;</span><br><span class="line">    ngx_queue_t                   queue;</span><br><span class="line">&#125; ngx_http_limit_req_shctx_t;</span><br></pre></td></tr></table></figure>

<p>基本上将该片shm是通过红黑树和队列的方式组织的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_rbtree_init(&amp;ctx-&gt;sh-&gt;rbtree, &amp;ctx-&gt;sh-&gt;sentinel,</span><br><span class="line">                    ngx_http_limit_req_rbtree_insert_value);</span><br><span class="line">    ngx_queue_init(&amp;ctx-&gt;sh-&gt;queue);</span><br></pre></td></tr></table></figure>

<p>这里多说一下，在limit_conn中，只有rbtree的方式，后面会分析到在limit_conn场景中，只有快速插入、查找的需求，而在limit_req中，多了queue的组织方式，这里的queue是用来做lrucache，为了避免内存溢出，将访问时间近的节点插入队头。</p>
<p>在初始化shm的时候还有一个地方值得注意<br><code>ctx-&gt;shpool-&gt;data = ctx-&gt;sh;</code></p>
<p>为啥要有这样的操作：主要是为了判断是否已经初始化这片shm，防止二次初始化，和业务逻辑没有关系，是shm框架使用。</p>
<ul>
<li>使用shm<br>shm初始化完毕后，将通过location级别的指令指定使用那块shm，看下配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_zone=one burst=5 nodelya</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过名称指定使用哪块内存，将其保存在lcf结构中，这是location级别相关的存储结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_shm_zone_t              *shm_zone;</span><br><span class="line">    /* integer value, 1 corresponds to 0.001 r/s */</span><br><span class="line">    ngx_uint_t                   burst;</span><br><span class="line">    ngx_uint_t                   nodelay; /* unsigned  nodelay:1 */</span><br><span class="line">&#125; ngx_http_limit_req_conf_t;</span><br></pre></td></tr></table></figure>

<p>其中shm_zone指向shm，burst和nodelay直接解析指令可以得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrcf-&gt;shm_zone = ngx_shared_memory_add(cf, &amp;s, 0,</span><br><span class="line">                                                   &amp;ngx_http_limit_req_module);</span><br></pre></td></tr></table></figure>

<p>即通过名称找到先前初始化ok的shm。</p>
<p>小结：以上是配置解析过程，总的来说就是将shm初始化完毕，然后通过name找到将要使用的shm联系起来。从中可以学习到shm的一般使用流程。</p>
<h3 id="4-算法流程"><a href="#4-算法流程" class="headerlink" title="4 算法流程"></a>4 算法流程</h3><p>下面是每个请求流过handler时候的逻辑，也是限流算法的核心：针对每个请求级别生效。对于limit_conn来说比较简单，先分析其handler： <code>ngx_http_limit_zone_handler</code></p>
<ul>
<li>limit_conn</li>
</ul>
<p>1 首先判断，这个r进入的location是否有定义限速：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lccf = ngx_http_get_module_loc_conf(r, ngx_http_limit_conn_module);</span><br><span class="line">    if (lccf-&gt;shm_zone == NULL) &#123;</span><br><span class="line">        return NGX_DECLINED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>若该location没有设定限速，则直接跳过。（若设置了限速，lccf-&gt;shm_zone的值会指向某块内存，前面已述。</p>
<p>2 取出请求上变量值、查找<br><code>vv = ngx_http_get_indexed_variable(r, ctx-&gt;index);</code><br>根据值在rbtree上进行查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">while (node != sentinel) &#123;</span><br><span class="line">        if (hash &lt; node-&gt;key) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;   </span><br><span class="line">        if (hash &gt; node-&gt;key) &#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        /* hash == node-&gt;key */</span><br><span class="line">        lz = (ngx_http_limit_zone_node_t *) &amp;node-&gt;color;</span><br><span class="line">        rc = ngx_memn2cmp(vv-&gt;data, lz-&gt;data, len, (size_t) lz-&gt;len);</span><br><span class="line">        if (rc == 0) &#123;</span><br><span class="line">            if ((ngx_uint_t) lz-&gt;conn &lt; lzcf-&gt;conn) &#123;</span><br><span class="line">                lz-&gt;conn++;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            ngx_shmtx_unlock(&amp;shpool-&gt;mutex);</span><br><span class="line">            ngx_log_error(lzcf-&gt;log_level, r-&gt;connection-&gt;log, 0,</span><br><span class="line">                          &quot;limiting connections by zone \&quot;%V\&quot;&quot;,</span><br><span class="line">                          &amp;lzcf-&gt;shm_zone-&gt;shm.name);</span><br><span class="line">            return NGX_HTTP_SERVICE_UNAVAILABLE;</span><br><span class="line">        &#125;</span><br><span class="line">        node = (rc &lt; 0) ? node-&gt;left : node-&gt;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑也是十分直接：若rbtree中有相应节点，判断节点的lr-&gt;conn是否超过设定location的lzcf-&gt;conn值，若没有超过，则增加该key的lr-&gt;conn值，然后直接放过，若超过了，则直接503掉。</p>
<p>至于放过后的请求，需要做收尾处理：当请求处理完成后，需要将lr-&gt;conn的值恢复，cleanup适合做这件事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cln = ngx_pool_cleanup_add(r-&gt;pool, sizeof(ngx_http_limit_zone_cleanup_t));</span><br><span class="line">（cln可以申请一块空间作为handler的参数：cln-&gt;data</span><br><span class="line">cln-&gt;handler = ngx_http_limit_zone_cleanup;</span><br><span class="line">lzcln = cln-&gt;data;</span><br><span class="line">lzcln-&gt;shm_zone = lzcf-&gt;shm_zone;</span><br><span class="line">lzcln-&gt;node = node;</span><br><span class="line"></span><br><span class="line">定义如下</span><br><span class="line"></span><br><span class="line">ngx_http_limit_zone_cleanup&#123;</span><br><span class="line">lz-&gt;conn--;</span><br><span class="line">    if (lz-&gt;conn == 0) &#123;</span><br><span class="line">        ngx_rbtree_delete(ctx-&gt;rbtree, node);</span><br><span class="line">        ngx_slab_free_locked(shpool, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将相应节点的conn恢复，若发现为0了，则将相应节点从rbtree中摘掉。</p>
<p>cleanup机制在nginx中使用十分场景，它提供了相当优雅的价值，为结束请求收尾处理提供了便利。</p>
<p>回到上面，如果没有在rbtree中找到相应key，则申请节点空间后插入rbtree,并初始化相应节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = offsetof(ngx_rbtree_node_t, color)</span><br><span class="line">        + offsetof(ngx_http_limit_zone_node_t, data)</span><br><span class="line">        + len;</span><br><span class="line">    node = ngx_slab_alloc_locked(shpool, n);</span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        ngx_shmtx_unlock(&amp;shpool-&gt;mutex);</span><br><span class="line">        return NGX_HTTP_SERVICE_UNAVAILABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    lz = (ngx_http_limit_zone_node_t *) &amp;node-&gt;color;</span><br><span class="line">    node-&gt;key = hash;</span><br><span class="line">    lz-&gt;len = (u_char) len;</span><br><span class="line">    lz-&gt;conn = 1;</span><br><span class="line">    ngx_memcpy(lz-&gt;data, vv-&gt;data, len);</span><br></pre></td></tr></table></figure>

<ul>
<li>小结：limit_conn的算法就是这样，从代码中分析可以看出，limit_conn的限速是一个存量的限速状态。</li>
</ul>
<h4 id="limit-req"><a href="#limit-req" class="headerlink" title="limit_req"></a>limit_req</h4><p>下面分析稍微复杂一些的limit_req限速：其算法和典型的漏桶算法限速有些类似。在此之前先了解下什么是漏桶算法：</p>
<p><img src="https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/22a870dcdd2a06cf6605a4b441044fc8.png" alt="image.png"></p>
<p>一个形象的解释是</p>
<ul>
<li>水（请求）从上方倒入水桶，从水桶下方流出（被处理）；</li>
<li>来不及流出的水存在水桶中（缓冲），以固定速率流出；</li>
<li>水桶满后水溢出（丢弃）。<br>这个算法的核心是：缓存请求、均匀处理、多余请求直接丢弃。</li>
</ul>
<p>有了对算法形象的理解，再结合代码看nginx是如何实现该算法。</p>
<p>1 和limit_conn类似，首先判断该location是否开启了limit_req</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrcf = ngx_http_get_module_loc_conf(r, ngx_http_limit_req_module);</span><br><span class="line">    if (lrcf-&gt;shm_zone == NULL) &#123;</span><br><span class="line">        return NGX_DECLINED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2 计算限速变量、查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rc = ngx_http_limit_req_lookup(lrcf, hash, vv-&gt;data, len, &amp;excess);</span><br></pre></td></tr></table></figure>

<p>这里的返回值有几种情况：OK、BUSY、AGAIN、DECLINE<br>从简单的说起<br>DECLINE表示未查到相应节点，此时申请节点空间、初始化赋值后直接插入rbtree、queue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">if (rc == NGX_DECLINED) &#123;</span><br><span class="line"></span><br><span class="line">       n = offsetof(ngx_rbtree_node_t, color)</span><br><span class="line">           + offsetof(ngx_http_limit_req_node_t, data)</span><br><span class="line">           + len;</span><br><span class="line"></span><br><span class="line">       node = ngx_slab_alloc_locked(ctx-&gt;shpool, n);</span><br><span class="line">       if (node == NULL) &#123;</span><br><span class="line"></span><br><span class="line">           ngx_http_limit_req_expire(ctx, 0);</span><br><span class="line"></span><br><span class="line">           node = ngx_slab_alloc_locked(ctx-&gt;shpool, n);</span><br><span class="line">           if (node == NULL) &#123;</span><br><span class="line">               ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex);</span><br><span class="line">               return NGX_HTTP_SERVICE_UNAVAILABLE;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       lr = (ngx_http_limit_req_node_t *) &amp;node-&gt;color;</span><br><span class="line"></span><br><span class="line">       node-&gt;key = hash;</span><br><span class="line">       lr-&gt;len = (u_char) len;</span><br><span class="line"></span><br><span class="line">       tp = ngx_timeofday();</span><br><span class="line">       lr-&gt;last = (ngx_msec_t) (tp-&gt;sec * 1000 + tp-&gt;msec);</span><br><span class="line"></span><br><span class="line">       lr-&gt;excess = 0;</span><br><span class="line">       ngx_memcpy(lr-&gt;data, vv-&gt;data, len);</span><br><span class="line"></span><br><span class="line">       ngx_rbtree_insert(&amp;ctx-&gt;sh-&gt;rbtree, node);</span><br><span class="line"></span><br><span class="line">       ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;queue, &amp;lr-&gt;queue);</span><br><span class="line"></span><br><span class="line">       ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">       return NGX_DECLINED;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很清晰：先申请空间，若空间不够，则从queue中进行lru淘汰一些节点（其实是直接从队尾删除，访问时间最久的点放在队尾）。 初始化节点，插入tree，插入queue首。直接返回，将请求交给下一个handler处理。</p>
<p>返回OK： 说明没有超过相应限速值，直接放过；<br>返回BUSY：    超过限速值，且漏桶容量不够，直接503掉；<br>返回AGAIN：超过限速值，但漏桶容量够，进一步看是否需要delay/delay处理，如果设置了nodelay，那么效果和返回OK一样，立即放行，如果没有设置，那么需要delay处理，nginx实现dealy处理的方法是，将该请求放入timer中，将该请求可写事件加入timer树。</p>
<p>如果结合漏桶算法的场景，这里的桶是指每个key都会有自己的桶。</p>
<p>回到lookup中去，漏桶算法的思想在其中：(截取）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">if (rc == 0) &#123;</span><br><span class="line">    ngx_queue_remove(&amp;lr-&gt;queue);</span><br><span class="line">    ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;queue, &amp;lr-&gt;queue);</span><br><span class="line"></span><br><span class="line">    tp = ngx_timeofday();</span><br><span class="line"></span><br><span class="line">    now = (ngx_msec_t) (tp-&gt;sec * 1000 + tp-&gt;msec);</span><br><span class="line">    ms = (ngx_msec_int_t) (now - lr-&gt;last);</span><br><span class="line"></span><br><span class="line">    excess = lr-&gt;excess - ctx-&gt;rate * ngx_abs(ms) / 1000 + 1000;</span><br><span class="line"></span><br><span class="line">    if (excess &lt; 0) &#123;</span><br><span class="line">        excess = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ep = excess;</span><br><span class="line"></span><br><span class="line">    if ((ngx_uint_t) excess &gt; lrcf-&gt;burst) &#123;</span><br><span class="line">        return NGX_BUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lr-&gt;excess = excess;</span><br><span class="line">    lr-&gt;last = now;</span><br><span class="line"></span><br><span class="line">    if (excess) &#123;</span><br><span class="line">        return NGX_AGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果查找到了相应key，先将其插入queue头，更新访问lr-&gt;last。漏洞算法的核心在这一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">excess = lr-&gt;excess - ctx-&gt;rate * ngx_abs(ms) / 1000 + 1000;</span><br></pre></td></tr></table></figure>

<p>其中lr-&gt;excess表示该key还剩多少请求未被处理，其更新方式为 : 上一次遗留 -  在此段时间已经处理的个数(如果按照限定的速度来估算）。</p>
<p>若遗留的数据以及超过了桶的大小(lrcf-&gt;burst),那么返回busy,将拒掉请求。</p>
<p>如果excess为0，则表示可以放行请求。（桶内没有数据）</p>
<p>如果不为0，但也没超过桶大小，则会视nodelay配置情况进入延迟处理。</p>
<p>而在delay情况下，nginx如何结合timer进行延迟处理的？</p>
<p>1 首先计算需要delay该请求多久：excess * 1000 / ctx-&gt;rate</p>
<p>2 将可写时间加入timer，同时将请求的可读事件加入epoll</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (ngx_handle_read_event(r-&gt;connection-&gt;read, 0) != NGX_OK) &#123;</span><br><span class="line">        return NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;read_event_handler = ngx_http_test_reading;</span><br><span class="line">    r-&gt;write_event_handler = ngx_http_limit_req_delay;</span><br><span class="line">    ngx_add_timer(r-&gt;connection-&gt;write,</span><br><span class="line">                  (ngx_msec_t) excess * 1000 / ctx-&gt;rate);</span><br></pre></td></tr></table></figure>

<p>解析：将可写时间加入timer好理解，当timer触发式将继续执行该请求。这里首先将可读事件加入epoll中，原因是若在此期间收到了客户端的fin包，需要将该请求终止掉。</p>
<p>在可写事件的handler中： 下面贴出完整的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">ngx_http_limit_req_delay(ngx_http_request_t *r)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_event_t  *wev;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,</span><br><span class="line">                   &quot;limit_req delay&quot;);</span><br><span class="line"></span><br><span class="line">    wev = r-&gt;connection-&gt;write;</span><br><span class="line"></span><br><span class="line">    if (!wev-&gt;timedout) &#123;</span><br><span class="line"></span><br><span class="line">        if (ngx_handle_write_event(wev, 0) != NGX_OK) &#123;</span><br><span class="line">            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wev-&gt;timedout = 0;</span><br><span class="line"></span><br><span class="line">    if (ngx_handle_read_event(r-&gt;connection-&gt;read, 0) != NGX_OK) &#123;</span><br><span class="line">        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;read_event_handler = ngx_http_block_reading;</span><br><span class="line">    r-&gt;write_event_handler = ngx_http_core_run_phases;</span><br><span class="line"></span><br><span class="line">    ngx_http_core_run_phases(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种延迟处理请求的做法值得学习，忽略可读事件，调用ngx_http_core_run_phases再次进去请求的处理阶段。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个limit_conn/limit_req算法从源码上就分析完毕了，从中至少可以学习到以下知识：</p>
<p>1 shm的使用、组织、初始化</p>
<p>2 如何延迟处理请求（在C层面的实现）</p>
<p>3 漏桶算法在nginx中的实现</p>
<p>4 更加优雅地组织nginx模块。</p>
<p>谢谢</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/货币金融学笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/货币金融学笔记/" class="post-title-link" itemprop="url">货币金融学笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 21:39:32 / 修改时间：21:43:06" itemprop="dateCreated datePublished" datetime="2019-09-30T21:39:32+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>=====<br>仅是个人理解</p>
<h2 id="第一章-基础前言"><a href="#第一章-基础前言" class="headerlink" title="第一章 基础前言"></a>第一章 基础前言</h2><ul>
<li><p>本书将通过考察金融市场（例如债券市场、股票市场、外汇市场）和金融机构（也叫金融中介，如银行、保险公司、共同基金和其它金融机构）的运作，来探寻货币在经济中的角色。</p>
</li>
<li><p>企业在高利率的经济环境中，可能会推迟新建工厂，从而对就业产生不利影响。</p>
</li>
<li><p>债券市场可以帮助政府和企业筹集到所需要的资金，是决定利率的场所。</p>
</li>
<li><p>金融市场和金融机构的关系：金融机构是金融尺长能够运行的关键所在，没有金融机构，金融市场久无法实现资金由储蓄者相有生产性投资机会的人的转移。</p>
</li>
<li><p>银行：是（吸收存款和发放贷款的）金融机构，具体而言，又可以分为商业银行、储蓄、信贷协会、互助储蓄、信用社等。银行是经济规模中最大的金融机构。</p>
</li>
<li><p>货币与经济周期：每次经济衰退前，都伴随着货币增长率的下降，说明货币供给的变动是经济周期波动的推动力之一。然而并非每次货币增长率下降都会出现经济衰退。</p>
</li>
<li><p>货币与通货膨胀：物价水平和货币供给的走势都相当一致，着表妹，货币供给的持续增加是物价水平持续上升（即通货膨胀）的一个重要原因。</p>
</li>
<li><p>货币政策：即对货币和利率的管理，中央银行负责货币政策的实施。</p>
</li>
<li><p>财政政策：指政府对政府支出和税收的决策。预算赤字：在一年中，政府支出超过税收，预算盈余：在一年中政府支出小于税收。</p>
</li>
</ul>
<p>（预算赤字可能导致较高的货币增长率、较高的通货膨胀和较高的利率 ）<br>（即货币政策由央行实施，财政政策由政府实施）（本国嘛，你懂的）</p>
<ul>
<li><p>外汇市场： 跨国转移的资金必须由流出国的货币兑换为流入国的货币。</p>
</li>
<li><p>汇率的变动会影响进口成本，对消费者的影响是直接的.</p>
</li>
<li><p>本国汇率下跌，意味着外国商品变贵，出国度假（服务）变贵，会减少本国消费外国商品和服务，增加对本国消费商品和服务，提振本国就业市场。</p>
</li>
<li><p>本国汇率上升：意味着外国商品变便宜，会增加本国消费外国商品和服务，减少对本国消费商品和服务，冲击本国就业市场。</p>
</li>
</ul>
<h2 id="第二章-金融机构和金融市场"><a href="#第二章-金融机构和金融市场" class="headerlink" title="第二章 金融机构和金融市场"></a>第二章 金融机构和金融市场</h2><ul>
<li><p>苹果公司发明了更好的ipod，需要资金将其投放市场，此时金融市场和金融中介就登场了。同样，地方政府，相当于一个苹果公司，需要资金修建公路和建设学校，但地方税收无法<br>满足，于是向金融市场和金融机构融资，即向银行融资，等收过路费再还给银行。中国的债务问题就是，地方政府借了银行的钱建桥修路后，却收不回过路费，换不了银行的钱。</p>
</li>
<li><p>融资由两种主要手段： 通过金融市场直接融资，通过金融中介机构间接融资。<br>福特公司通过发行债券或者股票进行直接融资。也可以向银行贷款进行间接融资。</p>
</li>
<li><p>资本：可以用来创造财富的财富，他可以是金融财富也可以是物质财富。金融市场有助于资本的合理配置，从而增加生产和提高效率。<br>在经济危机期间，金融市场遭受严重破坏，经济发展受阻。</p>
</li>
<li><p>一级市场：公司或者政府机构将其新发行的股票货债券等销售给最初购买者的金融市场。<br>二级市场：交易已经发行的证券的金融市场<br>一即市场并不为公众熟知，因为将证券销售给最初购买者的过程并不是公开进行的。<br>投资银行是一级市场上协助首次出售的重要金融机构：承销这些证券。<br>纽交所、纳斯达克都是著名的二级市场。介绍金融市场的书籍会把重点放在二级市场，也应该放在二级市场。</p>
</li>
<li><p>货币市场：根据交易证券的期限长短来区分，货币市场是交易短期债务工具的金融市场 。（如国库券，可转让存单等）<br>资本市场：交易长期债务工具的金融市场 （如股票，抵押贷款，企业债券，地方政府债券</p>
</li>
<li><p>金融中介机构：间接融资。<br>当企业试图为其业务活动寻求资金来源时，它们通常会求助于金融中介机构，而非证券市场。 原因可以从三个方面来回答：交易成本，风险分担，信息成本。</p>
</li>
<li><p>金融中介机构分类：<br>存款机构（主要指银行，包括商业银行、储蓄和贷款协会，信用社）<br>契约型储蓄机构（包括人寿保险，意外保险，养老基金）<br>投资中介机构（包括财务公司，共同基金）<br>需要了解它们的资产和负债类型。</p>
</li>
</ul>
<h2 id="第三章-什么是货币"><a href="#第三章-什么是货币" class="headerlink" title="第三章 什么是货币"></a>第三章 什么是货币</h2><ul>
<li><p>本书所指的货币：在产品和服务支付以及债务偿还中被普遍接受的东西，它与收入和财富是有区别的。</p>
</li>
<li><p>货币的交易媒介功能：货币是经济社会中至关重要的东西：由于它可以降低交易成本，鼓励专业户和劳动分工，因而是经济顺利运行的润滑剂。</p>
</li>
<li><p>货币的记账单位功能：我们不会说一件衣服值3股，而会说一件衣服300元</p>
</li>
<li><p>货币的价值存储功能：货币作为价值储藏手段并非独一无二的，任何资产包括货币、股票、债券、土地、房屋等都可以用来储藏餐饭，许多资产比货币更有价值储藏功能。<br>但为啥人们还愿意持有货币呢？流动性：即某一资产转为交易媒介的便利层度和速度。由于货币本身就是交易媒介，所以具有最高的流动性，而其他资产转为交易媒介（即货币）都需要支付交易成本，（比如佣金啥的）。<br>货币作为价值储藏手段的优劣要取决于物价水平。</p>
</li>
<li><p>为何电子货币没能够彻底取代纸质货币：1 首先，需要花费加高的成购置所需的计算机、读卡器、通信网络等，2 电子支付带了安全性和私密性的问题，未经授权的黑客闯入了某个计算机数据库，并更改了其中存储的信息，要防止这种犯罪行为并非易事，需要开发一个全新的对付安全问题的计算机科学领域。3 利用电子支付方式还有一个后果，会留下有关购买习惯的大量个人信息，人们担心政府、雇主和商户会得到这些数据，从而入侵我们的私人领域。</p>
</li>
<li><p>M1 ： 最狭义的货币指标，包括流动性最强的资产，即通货、活期存款等。且其通货中之爆款非银行公众持有的纸币和硬币，不包括ATM和隐患金库中的现金。<br>M2: 在M1的基础上增加了一些流动性不及M1的资产，如定期存款等，。<br>在2008年，美国M2的数量是M1的数量的4倍左右。</p>
</li>
<li><p>M1种的通货：人均持有的现金达2000美元。这个数目是很惊人的，通货体积大，易于被窃，并且不支付任何利息，因而大部分人不可能持有这么多美元通货。但这些美元都在什么地方呢？谁在持有这些美元呢？<br>1 犯罪分子持有大量美元，因为现金交易不易被追踪。<br>2 企业愿意持有大量美元，因为现金交易很难被追踪，可以避免申报需要交税的收入<br>3 外国人由于担心本币价值贬值，不愿意相信本币，为了规避通货膨胀风险。例如俄罗斯人不信任卢布，大量持有美元。一半以上的美元都在海外</p>
</li>
</ul>
<h2 id="第四章-理解利率"><a href="#第四章-理解利率" class="headerlink" title="第四章 理解利率"></a>第四章 理解利率</h2><ul>
<li><p>你决定要购买房子，想银行借入10W的抵押贷款，你从银行的贷款利率为7%，要想在20年换完，每年还多少钱？<br>10W＝（x／1+7%）＋（x/(1+7%)^2) + (x /(1+7%)^3) +….+(x/(1+7%)^20))<br>解答得x＝9439.29 元。</p>
</li>
<li><p>利率最精准的定义：资产的到期收益率。 （以后说道利率，都是说的是市场利率）</p>
</li>
</ul>
<h2 id="第五章-利率行为"><a href="#第五章-利率行为" class="headerlink" title="第五章 利率行为"></a>第五章 利率行为</h2><ul>
<li><p>通过债券的需求供给曲线和水果市场的需求供给曲线，感觉到债券也是一种类似于水果的商品。<br>只不过水果市场的均衡是水果的需求和供给数量的均衡，而均衡点的位置就是水果的价格。即买房需要多少数量的水果，卖房需要卖出多少数量的水果。<br>而债券市场的均衡是债券的价格的均衡，而均衡点的位置就是利率。<br>感觉利率就是债券的真实价值，和价格代表水果的真实价值一样。（中间绕了一层）<br>当债券价格高，就代表水果供给多，需求相对过多，会导致债券价格下跌（水果供给变少），利率下跌（水果价格下降）<br>当债券价格低，就代表水果供给少，需求相对过少，会导致债券价格上升（水果供给变多），利率上升（水果价格上升）<br>债券价格的高低，相当于水果的供给多少。（价格高代表水果供给多，那么利率下跌）<br>反过来：<br>利率低，代表水果价格低，水果供给多，即债券价格高。<br>利率高，代表水果价格高，说过供给少，即债券价格低。</p>
</li>
<li><p>上面是债券和利率的关系，使用债券的供给和需求来讨论利率（市场利率）的变化情况和变化关系）<br>下面是货币的供给和需求来说明货币和利率的关系：利用凯恩斯的流动性偏好理论来解释</p>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/nginx个人笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/nginx个人笔记/" class="post-title-link" itemprop="url">nginx个人笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 21:32:10 / 修改时间：21:39:28" itemprop="dateCreated datePublished" datetime="2019-09-30T21:32:10+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ls-gt-handler钩子"><a href="#ls-gt-handler钩子" class="headerlink" title="ls-&gt;handler钩子"></a>ls-&gt;handler钩子</h3><p>ls结构体代表的是一个监听结构体，它的handler成员会随着nginx在哪一层来解释tcp流有所不不同</p>
<ul>
<li><p>http流<br>如果作为http来解释tcp流的话，其ls-&gt;handler为ngx_http_init_connection<br>(注：ls-&gt;handler的设置在解析http{}块的最后几步ngx_http_optimize_servers中设置的回调，包括创建ls结构体）.<br>每个listenfd都会有一个ls结构体，其ls-&gt;handler为其建立连接后初始化的钩子，即在accept后被调用，具体是在ngx_event_accept中.<br>每个lisenfd也会有一个c，rev，wev结构体与之对应，而其对应的rev的handler:rev-&gt;handler被设置为ngx_event_accept.这个过程在ngx_event_process_init中可以看到.<br>在epoll_wait的时候，由event_list[i].data.ptr指向了c，继而会找到rev、wev，然后待用rev-&gt;handler,这里就是ngx_event_accept了.<br>在ngx_event_accept中只是传递了ev结构体，那么如何找到了ls呢？答案就是ev-&gt;data会指向c，而在ngx_event_process_init中，每个listenfd对应的c的c-&gt;listening都会指向ls结构体，这样就找到了ls.<br>实际上，在ngx_event_accept中，新生产的c的c-&gt;listening也指向了被其accept的ls结构体.:)</p>
</li>
<li><p>stream流<br>对于四层流而言，在解析stream块时，ngx_stream_optimize_servers将ls-&gt;handler设置为乐ls-&gt;handler=ngx_stream_init_connection.</p>
</li>
</ul>
<h3 id="事件handler"><a href="#事件handler" class="headerlink" title="事件handler"></a>事件handler</h3><p>今天看了下框架层面的代码</p>
<ul>
<li>模块的init_process是在worker中执行的，所以是每个worker执行，而init_module是master的时候执行的，注意区分。</li>
<li>在Nginx中，连接c才有读写事件，c-&gt;rev/wev,请求没有这个概念，我们说读事件／写事件，都是说在该连接上发生的事件，而请求只是在连接之上的抽象，它没有读写事件的资格</li>
<li>在ngx_conf_parse中发现，cycle是main中的一个局部变量，同时注意区分cycle,cycle-&gt;conf_ctx(就是那个著名的void<em>*),conf (ngx_conf_t</em>,经常看到的cf）。</li>
<li>所有的事件钩子的参数都只有一个ev，而ev的data字段会指向其c字段，而c字段的data字段会指向r字段，这样就把c、r都找到了.（这里注意空闲的c的data字段是指向下一个空闲的c的）</li>
<li>注意区分事件handler和IO-handler的区别：事件处理handler是ev-&gt;handler,而IO-handler是存在c上的c-&gt;read/write，c-&gt;read=ngx_unix_recv,c-&gt;write=ngx_uint_send等等。而在ev-&gt;handler中可以使用它们来做IO。这中做法好棒，可扩展性强.</li>
</ul>
<h3 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h3><ul>
<li>最近写创建共享内存时候发现的,ngx_shared_memory_add,如果未赋值shm-&gt;init,shm-&gt;data,会导致-t检查不通过：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo ./nginx-1.6.2/obj/nginx -p `pwd` -c conf/nginx.conf -t</span><br><span class="line">nginx: the configuration of file /home/ke/test/web_server/nginx/try/conf/nginx.conf syntax is ok</span><br><span class="line">``` </span><br><span class="line">/*后面一句successfule居然就没有啦,加上后就可以了*/</span><br><span class="line">shm_zone-&gt;init=ngx_http_xxx_init_zone;</span><br><span class="line">shm_zone-&gt;data=shmctx;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加一种和event、http同等级的模块，写完后，发现配置指令错误：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo ./nginx-1.6.2/obj/nginx -p `pwd` -c conf/nginx.conf -t</span><br><span class="line">nginx:[emerg] &quot;xxx&quot; directive is not allowed here in /home/ke/test/web_server/nginx/try/conf/nginx.conf:17</span><br><span class="line">nginx:configuration file /home/ke/test/web_server/nginx/try/conf/nginx.conf test failed</span><br><span class="line">配置示例如下：</span><br><span class="line">events &#123;</span><br><span class="line">        worker_connection 1024;</span><br><span class="line">&#125;</span><br><span class="line">mylevel &#123;</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br><span class="line">后来发现问题是block钩子没有解析完导致的，把ngx_xxx_block解析写完成即可</span><br></pre></td></tr></table></figure>

<h3 id="cmd中的offset"><a href="#cmd中的offset" class="headerlink" title="cmd中的offset"></a>cmd中的offset</h3><p>以前在写cmd时候，之前以为offsetof(xxx,xx) 写了之后，就会对最后调用set函数时的conf有影响，即已经帮你找到了最终需要操作的字段。<br>现在经过验证，其实offsetof字段没有参与conf计算，你需要根据offsetof来自己确定最终的字段。如下：</p>
<p><img src="/images/nginx%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/1.png" alt></p>
<p><img src="/images/nginx%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/2.png" alt></p>
<p>  最后经过debug调试:</p>
<p><img src="/images/nginx%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/3.png" alt></p>
<p>打印出来的conf都是同一个位置，即loc_conf结构体，而并没有去在帮你找到具体的字段，需要你自己根据offsetof来找。parse_conf函数也证明了这点,即在拿到conf的时候并没有offset的参与:</p>
<p><img src="/images/nginx%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/4.png" alt></p>
<p>那么既然是这样，为何还要设置offsetof字段呢？反正可以通过conf来得到结构体，然后利用结构体就可以取得各个字段了。<br>其实，如果是自己写的set函数，这个offsetof是没有啥作用的，但是在采用预定义的那些set（如ngx_conf_set_flag_slot等），这时候就必须指定offsetof了，因为预定义的set使用了offsetof直接拿到具体的字段。</p>
<h3 id="content模块发送数据"><a href="#content模块发送数据" class="headerlink" title="content模块发送数据"></a>content模块发送数据</h3><p>在调用ngx_http_output_filter发送数据时，有时候会发现请求命令(如curl等客户端）迟迟不返回，这时候可用检查下buf的标志为buf-&gt;last_buf是否置位了。</p>
<h3 id="http模块的几个钩子的执行顺序"><a href="#http模块的几个钩子的执行顺序" class="headerlink" title="http模块的几个钩子的执行顺序"></a>http模块的几个钩子的执行顺序</h3><p>在阅读C模块时，老喜欢忘记ctx中的几个钩子执行顺序，这里做个记录：<br>|<br>create_main<br>|<br>create_srv<br>|<br>create_loc<br>|<br>preconfig – 一般在此处设置模块需要暴漏的变量<br>|<br>ngx_conf_parse – 解析http{},这样cmd中的钩子会全部执行<br>|<br>init_main<br>|<br>merge_srv<br>|<br>merge_loc<br>｜<br>init_locations –创建location的三叉树<br>|<br>init_phase – 创建phase表<br>|<br>post_config –一般这里会嵌入模块在各个阶段的钩子，或者filter钩子<br>|<br>optimze_server –初始化所有的http listenfd，包括挂接ls-&gt;handler</p>
<p>其实所有的流程都在ngx_http_block中一目了然，这里方便做个记录</p>
<h3 id="阅读dyups模块的笔记"><a href="#阅读dyups模块的笔记" class="headerlink" title="阅读dyups模块的笔记"></a>阅读dyups模块的笔记</h3><p>周末抽空阅读了下dyups早期的代码,这时候还只能在单worker中工作,所以以下分析主要是以这个版本的代码为基础的）</p>
<p><a href="https://github.com/yzprofile/ngx_http_dyups_module/tree/0c169da7dceeeecf956a84aa25ba1dcd108ec98e" target="_blank" rel="noopener">https://github.com/yzprofile/ngx_http_dyups_module/tree/0c169da7dceeeecf956a84aa25ba1dcd108ec98e</a><br>dyups模块与upstream模块结合得很紧密，主要是通过dyups暴漏出的几个API来操纵upstream模块里的数据结构体。关于获得操作比较易懂，通过获取upstream模块的数据然后展示出来，重点是DELETE和UPDATE的逻辑。</p>
<p>1 DELETE</p>
<ul>
<li>删除一个upstream块的核心逻辑是：将upstream模块的某个ngx_htt_upstream_srv_conf_t结构体下的所有server的状态都置为down us[i].down=1，然后再次初始化调用了uscf-&gt;peer.init_upstream(默认情况下该钩子为ngx_http_upstream_init_round_robin).<br>(其实这里不太理解为啥要做这个调用，我实践了下，感觉不做的话也没啥影响) 这里需要注意的是，uscf-&gt;peer有两个与初始化相关的钩子 init_upstream和init:</li>
</ul>
<ul>
<li>前一个钩子是在upstream模块的init_main_conf中配置文件解析后被调用的，和dyups模块这里调用的效果一样，初始化upstream模块里的数据</li>
</ul>
<ul>
<li>后一个钩子init是在每个请求（那些需要xxx_pass的）将要转发时被调用的，之所以是在这里而不是在初始化阶段，在《Nginx开发从入门到精通》里面解释的很好：<br>“nginx收到一个请求后，发现如果要访问upstream，就会执行对应的peer.init函数，这是在初始化配置时设置的回调函数(在调用init_upstream也即ngx_http_upstream_init_round_robin中时被设置）。这个函数的作用时构造一张表，当前请求可以使用的upstream服务器被依次添加到这张表中。之所以需要这张表，最重要的原因是如果upstream服务器出现异常，不能提供服务时，可以从这张表中取得其它服务器进行重试操作，此外这张表也可以用于进行负载均衡的计算。之所以构造这张表的行为放在这里而不是在前面初始化配置阶段，时因为upstream需要为每个请求提供独立隔离的环境。”</li>
</ul>
<ul>
<li>这样就可以解释为何dyups的DELETE仅仅将其us[i].down置位就能到达“删除”某个upstream块的效果了，而每个请求在prox时调用init来构造可用节点表时,发现每个节点都down，所以这个请求就502了.</li>
</ul>
<p>2 UPDATE(POST)</p>
<ul>
<li>增添</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/redis集群及ngx-lua接入方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/redis集群及ngx-lua接入方案/" class="post-title-link" itemprop="url">redis集群及ngx_lua接入方案</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 21:19:30 / 修改时间：21:29:11" itemprop="dateCreated datePublished" datetime="2019-09-30T21:19:30+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>细化分流和降级的项目依赖redis存放分流和降级规则，为了保证redis的高可用，需避免其单点故障和数据丢失。整个系统的架构图如下：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/1.png" alt></p>
<p>在管理端，通过多个管理实例来避免管理端的单点问题，将策略规则写入redis。在业务端，多个Nginx代理从redis中读出策略规则并缓存在本地的lua缓存中，结合用户请求，最终将其分流到不同的上游集群。</p>
<h3 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h3><p>1 当某个redis挂掉后，其上面的数据需要有备份，不能丢失。<br>2 整个redis集群须提供对外统一的访问接口。<br>为此考虑了以下几种解决方案：<br>1 主从模式<br>2 代理模式<br>3 集群模式</p>
<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>若用redis主从模式，其接入架构图可以为这样：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/2.png" alt></p>
<p>1 在所有redis中有一个主库，其余均为从库，所有从库始终保持和主库数据同步。<br>2 所有的管理机均将策略写入主库，各个业务机将从各自的从库中读人。可以将从库于业务机部署在同一主机提高读取速度。<br>该方案的特点：<br>1 实现简单。redis主从关系设置方便，且有现成的接入单个redis的lua接口。<br>2 容灾性差。所有管理机都依赖于唯一的主库，造成单点问题（虽说系统依然可以正常处理业务），且业务机访问单个redis从库，也造成单点问题。<br>3 。。。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为了让多个redis对外提供统一的访问接口，尝试采用redis的代理服务。根据调研，目前业界有两种成熟的解决方案：twemproxy和codis。其架构图如下：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/3.png" alt></p>
<p>通过代理，所有接入redis的请求都由代理来处理。<br>该方案的特点：<br>1 统一接口。代理对外提供了所有访问的统一接口，且可以兼容访问单个redis实例的lua接口<br>2 容灾较差。代理将数据写入或从redis集群中读出是采用分片的方式，从中选择某个redis来进行写或读。<br>如果某个redis挂了，其上面的数据依然会丢失。<br>针对2进行的改进是：对每个redis做主备，其架构如下</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/4.png" alt></p>
<p>这样虽然保证了数据不丢失，但主库挂掉时，从库需要手动升级为主库，运维麻烦。</p>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>集群模式是redis在3.0后的分布式解决方案，可以很好地满足上面的两个要求：1 对外提供统一接口 2 数据一致性且不丢失。其接入架构图如下：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/5.png" alt></p>
<p>集群中的所有redis都互相传递消息，且按照分片的方式进行存储数据。在本节介绍redis集群的部署方式后，在下一节介绍redis集群原理。</p>
<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p>1 运行多个处于集群模式的redis实例<br>这里以6个为例。要使redis处于集群模式，需在配置文件里面添加：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/6.png" alt></p>
<p>cluster-enabled表示是否以集群模式运行。其它字段意义可参考官网：<a href="http://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">http://redis.io/topics/cluster-tutorial</a></p>
<p>然后运行6个实例</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/7.png" alt></p>
<p>其客户端监听端口以此为6380,6381,6382,6383,6384,6385。</p>
<p>2 安装依赖</p>
<p>上面的6个实例虽然处于集群模式，但是各自为战，并没有构成真正意义上的集群，为此需要将其构成集群。<br>在redis包中有将redis实例构成集群的管理包，但运行其管理包需要安装依赖环境，包括ruby，gem等</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/8.png" alt><br><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/9.png" alt></p>
<p>3 构成集群</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/10.png" alt></p>
<p>其中redis-trib.rb是构成集群的命令，create表示创建集群，–replicas 1表示集群中的每个主节点都将附带一个从节点。</p>
<p>4 安装完成</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/11.png" alt></p>
<p>在集群中的6个节点中有3个主节点是负责真正写入和读出数据的，三个从节点将为其主节点备份，并在必要自动时候升级为主节点（没错，是自动升级，下一节会介绍其原理）</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/12.png" alt></p>
<p>PS：<br>1 红色的为主节点，该集群也就表示由这三个主节点构成，其从节点只是为其备份数据，并不参与集群的数据的读写。<br>2 每个节点（包括从节点）都会感知集群中的每个节点的状态，且每个主节点都可以设置多个从节点。<br>3 主节点间的数据不冗余（即每个主节点间的数据都不是备份关系），而是经过分片处理数据。每个节点处理一部分“槽位”，redis集群方案共设置了16384个槽位。</p>
<h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>开始时，集群中的每个节点都是单个的集群，它们之间通过“握手”来构建整个系统集群，以上面的三个主节点组成的系统为例，构建集群的过程如下：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/13.png" alt></p>
<p>首先6380节点和6381节点相会握手成功后，其会构件为一个集群，然后6381和6382握手成功后，所以的节点都加入了同一个集群。<br>在集群中的每个节点和在普通模式下运行的节点所代表的数据结构不同：clusterNode.</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/14.png" alt></p>
<p>每个节点中都有感知集群中其它节点的信息。</p>
<h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p>Redis集群是通过分片方式来保存数据的：整个集群的实现一共分为16384个槽（slot），这些槽在空间上组成环状。集群中的每个KV对都属于这16384个槽中的一个，且每个集群中的主节点可以处理0个或者多个槽，每个槽只属于一个主节点。<br>当16384个槽都被处理时，我们称集群处于上线状态（OK），可以通过每个主节点的clusterstatus结构体的state来标示。否则，任意一个槽没有被集群节点覆盖到，那么集群将处于线下状态（Fail）。<br>处于上线状态的集群中的每个主节点都感知每一个槽分别被哪个主节点处理的：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/15.png" alt></p>
<p>如上所示：槽0－5000被节点6380处理，5001-10000被节点6381处理，10000-16383被节点6382处理。<br>这样每个节点都能迅速掌握哪个槽被哪个节点处理。</p>
<h3 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h3><p>当集群接受到redis命令时，首先计算该键值对应的槽位，然后判断该槽位是否被当前节点所处理，所是，则直接处理，否则将返回MOVED错误给客户端，客户端会通过MOVED错误的信息转向正确的主节点进行处理。其答大体步骤如下：</p>
<p><img src="/images/redis%E9%9B%86%E7%BE%A4%E5%8F%8Angx-lua%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/16.png" alt></p>
<p>PS<br>1 键值与槽位的关系：<br>通过键值来计算槽位：CRC16(key)&amp;16383 。即先计算键值的CRC16校验和，然后得出一个介于0～16383间的整数做为key的槽位。<br>2 MOVED错误只有支持集群模式的客户段才能够正确处理（继续访问正确的主节点），否则将打印错误。</p>
<h3 id="复制故障转移"><a href="#复制故障转移" class="headerlink" title="复制故障转移"></a>复制故障转移</h3><p>如果集群中只包含主节点，那就大大降低了它的高可靠性，一般集群中的主节点都会有从节点。从节点主要用于在相应的主节点发生故障后代替成为主节点，实现故障转移，达到高可靠的特点。而这个过程在集群中是全部自动完成的。<br>1 集群中的每个主节点都感知各个主节点的从节点。<br>2 若集群中超半数的主节点认为某个主节点故障，则该主节点被下线。<br>3 某个主节点被下线的消息会被广播到所有节点（包括从节点）<br>4 当从节点（们）发现自己的主已经被判定为下线，那么这些从节点会向各个主节点发送选举请求，请求各个主节点支持自己成为主节点。<br>4 只有每个主节点有投票选举权，且只有一票。<br>5 若某个从节点已经得到过半主节点的投票，那么会将自己升级为主节点，同时接管原来主节点所处理的槽位，并向集群广播自己被选举成功的消息。</p>
<h3 id="接入细节"><a href="#接入细节" class="headerlink" title="接入细节"></a>接入细节</h3><p>想让上面的Redis集群接入到分流和降级系统中，需要有专门的Lua接口来接入redis集群。根据支持集群模式的C客户端和支持普通模式lua接口，可以构造支持集群模式的lua接口。</p>
<p>推荐：<a href="https://github.com/cuiweixie/lua-resty-redis-cluster" target="_blank" rel="noopener">https://github.com/cuiweixie/lua-resty-redis-cluster</a><br>PS:这个客户端有少许bug:<br>1 需要把local关键字加在redis实例前面，参考其PR<br>2 在高流量情况下，由于超时重试机制，导致一个请求创建了最多18个redis实例和超时timer，把LUA虚拟栈跑爆了，这个需要改造下</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/Nginx的网络模型演变/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/Nginx的网络模型演变/" class="post-title-link" itemprop="url">Nginx的网络模型演变</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 21:07:13 / 修改时间：21:17:56" itemprop="dateCreated datePublished" datetime="2019-09-30T21:07:13+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx的高性能得益于其优秀的网络架构模型。为了充分发挥多核CPU的优势，让每个进程都“亲缘”一个CPU，减少上下文切换带来的损耗，同时也需要解决多个进程监听同一个端口带来的各种问题，本文将简要描述下Nginx的网络架构的演变过程。</p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="模型一"><a href="#模型一" class="headerlink" title="模型一"></a>模型一</h3><p>Nginx是单主(master)多从(worker)模式的进程架构，Master进程在解析配置文件的时候，对于每个监听的端口，将创建一个监听socket套接字，为了描述，这里假设在配置文件中开启了80和443两个端口。其网络模型如下：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/1.png" alt></p>
<p>在解析完配置文件后，master进程开始创建子进程，这些子进程会进程master的资源，当然包括套接字等，如果开启4个worker，则其网络模型如下：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/2.png" alt></p>
<p>这时候，如果有请求来临，内核会唤醒所有的进程，这就是惊群现象。（先不谈Linux内核是否解决了惊群现象，Nginx作为一个跨平台的服务，必须从自身解决这个问题）<br>传统的网络服务（如apache等）会采用每个请求分派一个线程来处理，而Nginx采用的IO多路复用机制（有时候也叫做事件驱动），如在Linux平台的epoll，BSD平台的kqueue等，配合非阻塞的soket API，充分利用了CPU，提升了网络服务质量。下面会以Linux平台下的epoll为例，说明Nginx是如何解决惊群问题的。</p>
<p>1 各个worker进程会创建自己的epoll句柄（不包括master）<br>2 接着会判读，管理员是否开启了惊群锁且worker进程的数量大于1。<br>a,惊群锁默认是关闭的，如果管理员显示开启了accept_mutux off,则会禁用，Nginx就不会解决惊群问题。<br>b,如果worker的进程数量小于2，那么不存在惊群问题，Nginx也会不解决惊群问题。</p>
<p>3 如果惊群生效，则每个worker首先不会去把监听套接字描述符加入自己的epoll系统，而是先去抢一把自旋锁，即对所有监听套接字的“控制权”。</p>
<p>4 抢到锁的worker进程，会将所有的监听套接字都加入自己的epoll中，而没有抢到worker会首先删除自己epoll中监听的监听套接字（如果有的话）。这样当有新请求来到时，只会有一个worker被唤醒，从而解决了惊群的问题。</p>
<p>其流程图大约如下：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/3.png" alt></p>
<p>小结：<br>1，在请求量不是特别大的情况下，Nginx这种解决惊群现象的手段提升了网络服务质量，避免多个进程无谓的被“唤醒”去accept请求失败而导致的损耗。<br>2，然后现在在很多情况下证明：当并发请求量过大时，这种依靠抢锁机制解决惊群的手段，会导致处理请求的效率下降，所以现在较多的建议是关闭accept_mutux锁，让Nginx不解决惊群。</p>
<h3 id="模型二"><a href="#模型二" class="headerlink" title="模型二"></a>模型二</h3><p>在第一种模型下，通过抢锁来保障每次新请求到来时都只会有一个worker去执行accept，避免其它worker的无谓消耗。这种情况在高并发场景下受到了质疑，事实上，在高并发情况下，关闭惊群锁而不让Nginx处理“惊群”反而会提升处理效率。下面举一个例子说明：</p>
<p>试想，有一群小鸡，你撒谷粒给这群鸡吃。<br>a，一粒粒撒的时候，如果不加处理，每个鸡都会跳起来，但最终只有一只鸡能够吃到这粒米。<br>所以在一粒粒撒的时候，需要有锁，不能让每个鸡都跳起来，这样浪费它们的精力，必须要让它们遵守秩序，一个个来（加锁）</p>
<p>b，然而，如果你撒了一大把谷粒，这时候还让它们一个个来，这样是很不合理的，所以，在撒大把谷粒的情况下，这些鸡全部跳起来抢食才是科学的，这样才能更加快速地消耗掉这些谷粒。（不加锁）。<br>上面的小鸡就代表worker进程，谷粒代表高并发的请求，虽然比喻有些粗糙，但也能够说明问题。</p>
<p>所以，在高并发场景下，关闭惊群锁，每个worker都把所有的监听套接字加入到自己的epoll中去，让它们都试图去accept新的请求，这样做能够提升处理请求的效率。<br>而且，从高版本的Nginx开始，惊群锁也默认置为了关闭状态。<br>官方对此作了压力测试的对比，具体可见如下：<a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="noopener">https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/</a></p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/4.png" alt></p>
<p>(先忽略reuseport，比对default和accept_mutux off的两种情况）</p>
<h3 id="模型三"><a href="#模型三" class="headerlink" title="模型三"></a>模型三</h3><p>在Nginx1.9.1版本中，引入了新的socket网络选项，SO_REUSEPORT.<br>首先解释下这个选项：当socket设置了这个选项，可以让多个设置了这个选项的socket绑定和监听同一个端口（准确滴说是一个ip:port对）</p>
<p>1 default时候的网络模型：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/2.png" alt></p>
<p>在原始模型中，所有的worker通过master的fork调用，都公用一个socket来监听80端口(或其它端口）</p>
<p>如果开启SO_REUSEPORT特性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	server &#123;</span><br><span class="line">		listen 80 reuseport;</span><br><span class="line">		server_name localhost;</span><br><span class="line">		..</span><br><span class="line">&#125;// reuseport是listen指令后的选项。这和Tengine实现的在event块中的开启这个选项有所不一样。</span><br></pre></td></tr></table></figure>

<p>则master在解析配置文件的时候创建监听套接字会有不同的动作：<br>它会按照worker的数目 n,对于每个ip:port对，都会克隆出多个监听socket，如下：（以4个worker为例）</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/5.png" alt></p>
<p>可以看到，对于同一个端口，master建立了4个监听套接字，这四个监听套接字都bind到80端口。（需要注意的是，如果套接字不设置SO_REUSEPORT属性，那么当多个套接字bind到同一个端口时，会报错失败。当然这里每个套接字都设置了SO_REUSEPORT属性）</p>
<p>然后经过fork出worker进程：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/6.png" alt></p>
<p>然后，每个worker会根据自己的ID顺序号，将“属于自己”的监听套接字加入到自己的epoll中。（这段是翻看源码才能获知的，一开始怎么都想不明白～～）<br>以监听80端口的那四个套接字来说，worker1进程只会把套接字1加入自己的epoll中。如下图所示：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/7.png" alt></p>
<p>这样，每个worker都再也不用去抢监听锁讲监听套接字加入自己的epoll系统中了，现在每个worker的epoll中始终都有着属于自己的监听套接字。可以对比一下：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/8.png" alt></p>
<p>注意：在这种模式下，若某个端口有请求到来，是内核来决定将请求分发到那个监听套接字上，而且这种分发一般都是较为均衡的。</p>
<p>再来比对一下官方的测试数据：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/4.png" alt></p>
<p>其QPS和平均延时以及延时标准差都明显降低了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1 第一种默认的抢锁模式：<br>在大多数请求量适中的环境中都表现很优秀，而且从Nginx内部做到了解决惊群问题，具有跨平台的优势。而且由于解决了惊群问题，极大降低了CPU的负荷。</p>
<p>2 第二种“惊群”模式：<br>在第二种模式下，Nginx任由“惊群”现象的产生，让每个worker都尽自己的力量去抢到更多的请求。第二种模式在高并发场景下非常有效，但由于每次请求都会让所有worker去争抢请求，必然增大了CPU的负荷。</p>
<p>3 第三种reuseport模式：<br>在这种情况下，每个worker都有”专属于“自己的监听套接字，不用去挣抢锁，完全由内核将请求分发到各个套接字上面，做到了高效且降低CPU的负荷的特定。</p>
<p>下面是官方的对比：</p>
<p><img src="/images/Nginx%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98/9.png" alt></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/Nginx请求11个处理阶段/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/Nginx请求11个处理阶段/" class="post-title-link" itemprop="url">Nginx请求11个处理阶段</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 20:59:48 / 修改时间：21:08:20" itemprop="dateCreated datePublished" datetime="2019-09-30T20:59:48+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="模块钩子嵌入"><a href="#模块钩子嵌入" class="headerlink" title="模块钩子嵌入"></a>模块钩子嵌入</h2><p>在处理请求时，Nginx是分为11个不同的阶段来完成的。在Nginx中，模块对请求进行操作的唯一途径是在这11个阶段中嵌入自己的钩子函数。</p>
<h2 id="数据结构支持"><a href="#数据结构支持" class="headerlink" title="数据结构支持"></a>数据结构支持</h2><h3 id="嵌入范例"><a href="#嵌入范例" class="headerlink" title="嵌入范例"></a>嵌入范例</h3><p>HTTP类型的模块嵌入钩子的过程是在解析配置文件的过程中完成的。通常会在模块上下文的ngx_http_post_config的地方插入自己的钩子，如ngx_http_access_module这个模块：</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/1.png" alt></p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/2.png" alt></p>
<p>这个模块就在ACCESS阶段嵌入了一个自己的钩子:ngx_http_access_handler. （注意：也可以有模块在不同的阶段嵌入多个钩子或者同一阶段嵌入多个钩子，这都是可以的）<br>这些钩子的存放位置就在cmcf-&gt;phases这个数组中。</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/3.png" alt></p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/4.png" alt></p>
<p>可以看到，这个结构实际上是一个二维数组的形式，即不同阶段的钩子都是分开存放在不同的一维动态数组中的。</p>
<h3 id="钩子布局"><a href="#钩子布局" class="headerlink" title="钩子布局"></a>钩子布局</h3><p>为了对HTTP的钩子嵌入有直观的认识，下面是一个常规配置中其钩子的情景图：</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/5.png" alt></p>
<p>上图显示了常规情况下的钩子布局情况：<br>1，一共分为了11个阶段，“理论上”请求的处理过程是严格按照这个顺序来执行的。<br>2，并不是每个阶段都必须要有钩子，如上面的几个阶段是没有嵌入钩子的<br>3，每个阶段理论上可以嵌入任意多的钩子数量<br>4，第三方模块能够嵌入的阶段有限：0，1，3，5，6，9，10。而其它阶段（2，4，7，8）的钩子是由HTTP框架来嵌入的。</p>
<h2 id="运行时“变身”"><a href="#运行时“变身”" class="headerlink" title="运行时“变身”"></a>运行时“变身”</h2><h3 id="一维钩子数组"><a href="#一维钩子数组" class="headerlink" title="一维钩子数组"></a>一维钩子数组</h3><p>上面的钩子布局是由配置文件直接解析后生成的，但在处理http请求时，并不是按照上面的二维钩子数组来处理的，而是将其变成了一维数组。即运行时是以一维数组的形式来调用各个钩子的。<br>首先在cmcf结构体中除了cmcf→phases数组（即上面的那个二维数组）外，还有一个结构体cmcf-&gt;pahse_engine也和钩子函数的布局有关：</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/6.png" alt></p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/7.png" alt></p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/8.png" alt></p>
<p>cf-&gt;phase_engine的handlers字段是一个一维数组，它里面的内容由cmcf→phases二维钩子数组转换而来，它的存放的元素类型为ngx_http_phase_handlers_t结构体。<br>对于每个在二维数组中的钩子，都会在这个一维的handlers数组中对应着ngx_http_phases_handlers结构体（也即每个钩子都会有check，handler和next字段对应）。<br>在将二维钩子数组转换为一维钩子数组之前，需要对这个结构体的三个字段做简单的描述：<br>check: 一个包裹函数，每个钩子都会有一个check，且同一个阶段的所有钩子其check都是一样的，最重要的是，nginx从不直接调用钩子，而是调用其check，然后由check来调用钩子。<br>handler: 包裹的钩子函数，也即上面的钩子。<br>next：代表的含义相当于index，一维钩子数组下标。next表示从当前钩子所处阶段的下一个阶段中的第一个钩子在这个一维钩子数组中的下标，常用来快速跳到下一个阶段。<br>如果从上面的二维钩子数组转换为一维钩子数组来看，情景图如下：</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/9.png" alt></p>
<p>二维钩子数组中，每个阶段的钩子都按顺序被放在了相邻的一维钩子数组中.<br>补充说明：<br>1，r寻找到正确的server块（即r-&gt;srv_conf的正确指向）是在是这十一个阶段之前（在处理头部ngx_http_process_request_header的ngx_http_find_virtual_server中。也即在十一个处理阶段的前面。）<br>2，r寻找大正确的location块（即r→loc_conf的正确指向）是在FIND_CONFIG阶段。<br>3，r→main_conf肯定是唯一的（：））<br>4，在POST_REWRITE阶段（该阶段不能挂接自己的钩子，只会执行check函数）的next为1，暗示如果进行了rewrite跳转，那么下一个阶段会跳到FIND_CONF阶段去再次找寻到正确的location块。（通常如果没有rewrite的话，那么即phase＋＋，会进入PRE_ACCESS阶段。）</p>
<h3 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h3><p>在请求r的结构体中有一个字段为phase_handler,其类型为整型，这个整型为被赋值为一维钩子数组中的下标，由它来决定了请求在各个阶段的执行顺序或者跳转顺序。</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/10.png" alt></p>
<p>前面说过，在处理请求时，并不是直接调用各个钩子，而是调用了每个钩子的包裹函数-check函数:</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/11.png" alt></p>
<p>上面这段代码就是钩子函数被调用的核心逻辑：<br>以r-&gt;phase_handler为下标，调用相应的check函数，具体的check函数实现逻辑决定了r→phase_handler的变化，以及check函数的返回值决定了是否将控制流程交付给事件处理模块<br>即如果某个check函数返回了 NGX_OK，那么http模块就将控制流交付给了事件处理模块。<br>而check函数的返回值又和具体的钩子返回值有关，所以为了能够了解请求的执行顺序或跳转顺序，需要知道check函数对r→phase_handler的影响以及各个check函数的返回值。</p>
<h2 id="各阶段顺序详解"><a href="#各阶段顺序详解" class="headerlink" title="各阶段顺序详解"></a>各阶段顺序详解</h2><h3 id="check包裹函数"><a href="#check包裹函数" class="headerlink" title="check包裹函数"></a>check包裹函数</h3><p>下图总结了各个阶段的不同check包裹函数，其中有些阶段共用了一种check函数：</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/12.png" alt></p>
<p>有三个不同的阶段（POST_READ,PREACCESS,LOG)共用了check函数:ngx_http_core_generic_phase. 两个不同阶段(SERVER_REWRTIE,REWRITE)共用了ngx_http_core_rewrite_phase.其余都是各自有check函数。<br>而开发者需要关注的check只有4个（因为只可以嵌入的7个阶段中）：</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/13.png" alt></p>
<p>下面小节会逐步介绍它们中实现的逻辑是如何影响钩子的执行顺序的。</p>
<h4 id="ngx-http-core-generic-phase"><a href="#ngx-http-core-generic-phase" class="headerlink" title="ngx_http_core_generic_phase"></a>ngx_http_core_generic_phase</h4><p>有三个阶段都共用了此check方法，如果要在post_read,preaccess,log阶段嵌入自己的钩子，那么必须对这个check有了解。<br>1 首先会调用模块嵌入的钩子，即handler. (当然第三方模块实现的钩子函数必须是非阻塞的），根据handler的返回值，它会有4中不同的逻辑。<br>2 若handler返回NGX_OK, 意味着当前阶段以及执行完毕，那么需要跳转到下一阶段的第一个钩子，即将r→phase_handler赋值为next，即使该阶段还有其它钩子，那么也将忽略不执行。同时check方法返回NGX_AGAIN.（返回AGAIN是保留了HTTP框架的控制流的）<br>3 若handler返回NGX_DECLINED,则会执行下一个钩子（举例来说，如果当前阶段有多个钩子，那么会继续在当前阶段执行下一个钩子，若该阶段只有这一个钩子，那么会流转到下一个阶段执行钩子），它将r→phase_handler＋＋。同时check返回AGAIN(保留控制流权）<br>4 若handler返回NGX_DONE/NGX_AGAIN,那么表示该handler没有处理完，需要多次调度才能完成（例如遇到了阻塞条件或者超时），这时候需要将控制权交出去，且r→phase_handler保持不变以便epoll在此触发时会继续调用此钩子。这时候check返回OK，交付控制流权给事件模块。<br>5 若handler返回其它值，表示执行遇到错误，需要结束这个请求，调用ngx_http_finalize_request.<br>故实现自己的钩子时需要根据逻辑确定返回值，进而影响到check的动作。</p>
<h4 id="ngx-http-core-rewrite-phase"><a href="#ngx-http-core-rewrite-phase" class="headerlink" title="ngx_http_core_rewrite_phase"></a>ngx_http_core_rewrite_phase</h4><p>两个重写URL的阶段（server_rewrite,rewrite）共用了这个check。其逻辑和generic很相似<br>1 若handler返回NGX_DECLINED,则会执行下一个钩子（举例来说，如果当前阶段有多个钩子，那么会继续在当前阶段执行下一个钩子，若该阶段只有这一个钩子，那么会流转到下一个阶段执行钩子），它将r→phase_handler＋＋。同时check返回AGAIN(保留控制流权）<br>2 若handler返回NGX_DONE,那么表示该handler没有处理完，需要多次调度才能完成（例如遇到了阻塞条件或者超时），这时候需要将控制权交出去，且r→phase_handler保持不变以便epoll在此触发时会继续调用此钩子。这时候check返回OK，交付控制流权给事件模块。<br>3 若handler返回其它值(除DECLINED和DONE的其它值），表示执行遇到错误，需要结束这个请求，调用ngx_http_finalize_request.</p>
<p>PS：和上一个check包裹不同的是，这个check不会试图跳转到下一个阶段，即handler没有机会返回NGX_OK而得到正确处理。原因是，NGINX认为在重写URL这个点上，所有模块的优先级都是一样的，不应该存在先被调用的钩子会将其它钩子的执行权限“剥夺”的逻辑。</p>
<h4 id="ngx-http-core-access-phase"><a href="#ngx-http-core-access-phase" class="headerlink" title="ngx_http_core_access_phase"></a>ngx_http_core_access_phase</h4><p>(暂无）</p>
<h4 id="ngx-http-core-content-phase（实际上的最后一阶段"><a href="#ngx-http-core-content-phase（实际上的最后一阶段" class="headerlink" title="ngx_http_core_content_phase（实际上的最后一阶段)"></a>ngx_http_core_content_phase（实际上的最后一阶段)</h4><p>该阶段有两个特点：<br>a 这是第三方模块最经常嵌入的阶段<br>b 嵌入这个阶段的方式有两种（其它阶段都只有唯一的一种）<br>该阶段的作用是真正处理请求内容。<br>1 实际上该阶段是请求处理的最后一个阶段（LOG阶段是在请求结束的时候被执行的），那么就不会有跳转到下一个阶段的逻辑<br>2 其余阶段均为对所有的请求都有作用，而在CONTENT阶段，应该有这样的逻辑：即只对匹配了某个location的请求进行处理，这是该阶段的第二种嵌入方式<br>其实现方式如下：<br>1 在该location下的ngx_http_core_loc_conf_t结构体中赋值clcf→handler.<br>2 在请求r的字段中r→content_handler 中，将其赋值为的clcf→handler.<br>3 包裹函数的处理逻辑：</p>
<p><img src="/images/Nginx%E8%AF%B7%E6%B1%8211%E4%B8%AA%E5%A4%84%E7%90%86%E9%98%B6/14.png" alt></p>
<p>PS:<br>1 若clcf的handler被调用，则这一阶段的其它钩子将被忽略。<br>2 若content钩子返回非DECLINED，则意味着该请求被处理完成，结束。<br>3 由于该阶段是实际处理请求的最后一阶段，所以需要对下一个钩子是否存在做有效性检查。<br>4 一般在content阶段的钩子会构造响应头部和响应体，然后发送出去。（如常见的static_handler获取静态文件然后发送的module）</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/openssl自建CA后颁发证书/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/openssl自建CA后颁发证书/" class="post-title-link" itemprop="url">openssl自建CA后颁发证书</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 20:57:52" itemprop="dateCreated datePublished" datetime="2019-09-30T20:57:52+08:00">2019-09-30</time>
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/nginx中IP与证书的数量关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/nginx中IP与证书的数量关系/" class="post-title-link" itemprop="url">nginx中IP与证书的数量关系</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 20:50:04 / 修改时间：20:56:14" itemprop="dateCreated datePublished" datetime="2019-09-30T20:50:04+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于SSL协议在HTTP协议之上，当客户端和服务器建立ssl连接的时候，是在TCP之上建立的ssl连接，这时候由于服务器是不会收到host等http的字段，这时候如果是多vhost的服务器（如nginx），那么它就不知道传送哪个证书给客户端。所以有一种说法就是：一台单ip服务器只能支持配置一个证书[1][2]。不过HTTPS中的SNI扩展已经解决了这个问题，让单个IP的服务器能够支持任意多的域名证书。</p>
<h2 id="一-SNI介绍"><a href="#一-SNI介绍" class="headerlink" title="一 SNI介绍"></a>一 SNI介绍</h2><p>SNI是https的一个特征，它允许在建立ssl连接的时候，客户端发送请求的域名放在字段SNI中（server name identification.）这样服务器在建立SSL连接的时候，就能知道客户端请求的是哪个vhost，然后将相应的证书传递过去。</p>
<h2 id="二-构建无SNI的环境"><a href="#二-构建无SNI的环境" class="headerlink" title="二 构建无SNI的环境"></a>二 构建无SNI的环境</h2><p>现在较高版本的nginx和openssl都默认支持了SNI扩展，想要复现无SNI的环境我可是花了一番功夫的。使用的nginx和openssl版本如下：<br>nginx-1.8.1<br>openssl-1.0.0d<br>(在高版本下的openssl下硬是没编译成功，老是报告编译错误。。）</p>
<p> 1 编译环境</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/1.png" alt> </p>
<p>其中最后一行是将SNI协议关闭，编译完成后查看是否已经关闭了tls：</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/2.png" alt> </p>
<p>ok,已经关闭了。</p>
<p>2 复现问题</p>
<p>在无SNI支持的环境下，我们来观察如果给多个vhost配置证书会发生怎样的情况。<br>配置如下：</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/3.png" alt> </p>
<p>生成nginx2和nginx4的证书私钥对（可以用自建CA后然后再签发，参考：openssl自建CA后颁发证书，这里就直接签发了)</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/4.png" alt> </p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/5.png" alt> </p>
<p>3 验证证书</p>
<p>访问站点一：</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/6.png" alt> </p>
<p>访问站点二：</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/7.png" alt> </p>
<p>可以看到，两个站点都加载了同一个证书，即站点一的证书。</p>
<h2 id="构建SNI环境"><a href="#构建SNI环境" class="headerlink" title="构建SNI环境"></a>构建SNI环境</h2><p>1 和构建无SNI环境类似，只需要将disable-tlsext改为enable-tlsext即可，观察：</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/8.png" alt> </p>
<p>ok,支持SNI了</p>
<p>2 配置站点后观察：<br>访问站点一：</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/9.png" alt> </p>
<p>访问站点二：</p>
<p><img src="/images/nginx%E4%B8%ADIP%E4%B8%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB/10.png" alt> </p>
<p>可以看到，站点二此时加载了自己的证书，即SNI生效了。</p>
<p>refer:<br>[1］<a href="http://www.111cn.net/sys/nginx/103081.htm" target="_blank" rel="noopener">http://www.111cn.net/sys/nginx/103081.htm</a><br>[2］<a href="http://www.ttlsa.com/web/multiple-https-host-nginx-with-a-ip-configuration/" target="_blank" rel="noopener">http://www.ttlsa.com/web/multiple-https-host-nginx-with-a-ip-configuration/</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/Nginx配置文件与运行时的逻辑关系浅谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="josephus.ftt">
      <meta itemprop="description" content="《红与黑》">
      <meta itemprop="image" content="/images/id.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/30/Nginx配置文件与运行时的逻辑关系浅谈/" class="post-title-link" itemprop="url">Nginx配置文件与运行时的逻辑关系浅谈</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-30 20:10:34 / 修改时间：20:49:56" itemprop="dateCreated datePublished" datetime="2019-09-30T20:10:34+08:00">2019-09-30</time>
            </span>
          
            

            
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>undefined</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>NaN:aN</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-配置示例"><a href="#一-配置示例" class="headerlink" title="一 配置示例"></a>一 配置示例</h2><p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image1.png" alt></p>
<p>以上面的Nginx配置为例，本次讨论都基于这个配置文件。在配置中忽略了一些额外选项。只保留了http块，server块，location块。</p>
<h2 id="二-配置文件解析过程"><a href="#二-配置文件解析过程" class="headerlink" title="二 配置文件解析过程"></a>二 配置文件解析过程</h2><p>Nginx是在将配置文件解析和加载完之后，然后开始fork子进程，进行连接处理。所以对于明白Nginx是如何加载配置文件以及加载后发生了什么很有必要理解清楚。<br>在加载和解析配置文件时，主要的工作就是调用各个模块的（包括核心模块，http模块等内置模块，也包括第三方模块）钩子函数。<br>而每个不同类型的模块的关键不同之处在于它们的ctx结构体的不同，具体如下：</p>
<p>CORE类型:</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image2.png" alt></p>
<p>Core类型的模块的ctx结构只有两个钩子。在ngx_init_cycle中被调用。下面看其调用顺序（关键）</p>
<p>ctx-&gt;create_conf(cf) (目前只有两个Core类型的module注册<br>        ｜<br>        ｜<br>ngx_parse_conf(file) 这个函数是解析配置文件的核心函数，在里面会有一堆的模块的cmd结构体中的钩子被调用。</p>
<p>注意：当这个函数返回的时候就代表整个配置文件已经解析完了。<br>在解析到event子段，http子段的时候，有两个特殊的cmd钩子被调用：ngx_event_block,ngx_http_block.<br>而这两个钩子又会使得event类型模块中的ctx结构中的钩子，http类型模块中的ctx结构体中的钩子被一一调用。</p>
<h3 id="1-遇到events子段被ngx-event-block激活的情况："><a href="#1-遇到events子段被ngx-event-block激活的情况：" class="headerlink" title="1 遇到events子段被ngx_event_block激活的情况："></a>1 遇到events子段被ngx_event_block激活的情况：</h3><p>Event类型的ctx的结构体钩子：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image3.png" alt></p>
<p>其中actions为一个钩子数组。其被调用的顺序：<br>module-&gt;create_conf<br>|<br>|<br>ngx_parse_conf(…) 进入 解析event{}部分，又一堆的event类型模块的cmd命令钩子被调用。<br>｜<br>｜<br>module-&gt;init_conf<br>至此，event{} 中的解析完成，ngx_event_block返回.</p>
<h3 id="2-遇到http子段被ngx-http-block激活的情况（关键点）"><a href="#2-遇到http子段被ngx-http-block激活的情况（关键点）" class="headerlink" title="2 遇到http子段被ngx_http_block激活的情况（关键点）"></a>2 遇到http子段被ngx_http_block激活的情况（关键点）</h3><p>http类型的ctx的结构体钩子:</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image4.png" alt></p>
<p>ctx-&gt;create_main_conf<br>ctx-&gt;create_srv_conf<br>ctx-&gt;create_loc_conf<br>ctx-&gt;preconfigurat<br>ngx_parse_conf() //进入解析http{}中的指令<br>在此中又会有一堆的cmd钩子函数被回调。其中包括解析遇到server指令的ngx_http_core_server(),解析upstream指令的ngx_http_upstream两个特殊钩子，<br>而在ngx_http_core_server钩子中:<br>1,会继续调用各个模块的create_srv_conf,create_loc_conf,<br>2,遇到location指令，会遇到一个特殊钩子:ngx_http_core_location，它会继续调用各个模块的create_loc_conf钩子 （所以，在http模块的ctx的钩子中，这些钩子不只是被调用一次，而是按照配置文件的格式被多次调用）<br>ctx-&gt;init_main_conf<br>ctx-&gt;merge_srv_conf<br>ctx-&gt;merge_loc_conf<br>ctx-&gt;postconfiguration;/// 这个钩子就是大部分模块获得拦截流量处理机会的关键，它一般会在phases数组中（非常重要，存放了http请求处理的11个阶段的各个钩子）插入自己的钩子，或者是在filter链表钩子中挂接自己的钩子,或者是设置clcf结构体的handler成员（后面详述）<br>ngx_http_init_phases_handler<br>ngx_http_optimize_servers (这两个函数也非常重要，不过不属于这里需要关注的：））</p>
<p>至此，ngx_http_block钩子就执行完毕，http{}中的指令也都解析完毕。配置文件就解析完成了</p>
<p>返回到在core类型中被调用的ngx_parse_file函数：调用 module-&gt;init_conf //目前只有一个core类型的模块注册了此钩子</p>
<p>这样整个配置文件就解析完毕了。其Nginx的基本数据结构的创建和初始化也都准备完毕。<br>从上面的分析来看，其钩子函数的执行符合 总－分－总 的调用架构。</p>
<h2 id="三-解析后的布局"><a href="#三-解析后的布局" class="headerlink" title="三 解析后的布局"></a>三 解析后的布局</h2><h3 id="1-基本配置的布局"><a href="#1-基本配置的布局" class="headerlink" title="1 基本配置的布局"></a>1 基本配置的布局</h3><p>以上面的配置文件为例，观察http ｛｝块中的结构体布局：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image5.png" alt></p>
<p>以上为以基本配置为范例解析后，nginx创建的有关http服务的结构布局。可以看到有多个srv块和loc块的冗余结构。<br>说明：<br>1，在http块中，存在完整的main，srv，loc三个上下文结构体数组，且main结构体数组是全局唯一的，比如ngx_http_core_main_conf,这些main_conf结构对于全局结构题的组织具有重要作用。<br>2，在srv块下面，它的main上下文结构体数组是继承的http快的，但srv块有着自己独立的srv和loc结构体数组<br>3，在loc块下面，它的main、srv上下文结构体数组都是继承自己上一层的srv的srv和loc结构体数组，但有着自己独立的loc结构体数组。</p>
<h3 id="2增添一个模块后的布局图"><a href="#2增添一个模块后的布局图" class="headerlink" title="2增添一个模块后的布局图"></a>2增添一个模块后的布局图</h3><p>下面增添一个三方模块，然后看其创建的结构体在整个布局图中的位置是如何安放的。模块的名字叫做ngx_http_test_access_module</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image6.png" alt></p>
<p>其ctx结构体如上，为该模块创建一个属于loc位置的结构体 ngx_http_test_access_loc_conf_t。</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image7.png" alt></p>
<p>那么当nginx加载模块并解析完配置文件后，其布局为：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image8.png" alt></p>
<p>可以看到，仅仅一个模块创建的loc结构体，在当前的配置结构下就有6份冗余。（取决于配置的结构体，当前是一个http块，两个server块，三个location块）</p>
<h2 id="四-配置指令与请求处理顺序的相互作用"><a href="#四-配置指令与请求处理顺序的相互作用" class="headerlink" title="四 配置指令与请求处理顺序的相互作用"></a>四 配置指令与请求处理顺序的相互作用</h2><h3 id="1-请求的11个处理阶段"><a href="#1-请求的11个处理阶段" class="headerlink" title="1 请求的11个处理阶段"></a>1 请求的11个处理阶段</h3><p>在ngx_http_main_conf_t结构体中（这个结构体全局仅一份），有种要的成员phases数组。</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image9.png" alt></p>
<p>它是相当于一个二维动态数组，其结构体如下图所示：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image10.png" alt></p>
<p>其中每个阶段都有一系列的属于该阶段的钩子函数 。（注意，这只是所有被组册的钩子函数刚开始的组织结构，后期会将这个二维钩子数组转变为一维的钩子数组）</p>
<h3 id="2-注册钩子"><a href="#2-注册钩子" class="headerlink" title="2 注册钩子"></a>2 注册钩子</h3><p>如上面所说的，http模块在组册钩子的时候会在ctx-&gt;postconfigruration函数。在test_access模块中我们注册自己的钩子：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image11.png" alt></p>
<p>选择在access阶段组册钩子： ngx_http_test_access_handler.</p>
<h3 id="3-配置指令与钩子间的执行关系"><a href="#3-配置指令与钩子间的执行关系" class="headerlink" title="3 配置指令与钩子间的执行关系"></a>3 配置指令与钩子间的执行关系</h3><h4 id="1-指令出现与否的与钩子的关系"><a href="#1-指令出现与否的与钩子的关系" class="headerlink" title="1 指令出现与否的与钩子的关系"></a>1 指令出现与否的与钩子的关系</h4><p>在配置文件中的指令配置、指令位置、指令配置与否这些条件在本质上都不能改变nginx的请求处理经过的顺序，而对请求的如何处理只和钩子函数的实现逻辑有关。<br>如上，因为在access阶段注册了钩子，那么所有的请求都会经过这个钩子的处理，即使不配置任何指令。<br>我们做个实验：在ngx_http_test_access_handler钩子中不做任何处理，直接返回403foridden。在模块的cmd指令做不设置任何指令，配置文件中不做任何配置。</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image12.png" alt></p>
<p>然后访问：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image13.png" alt></p>
<p>可以看到，任何访问都将被foridden，即使配置文件里面没有配置任何test_access的指令。<br>而我们也可以配置一个指令，让其具有开关的功能，如果开关打开，则放行，否则forbidden。</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image14.png" alt></p>
<p>其配置文件更改为：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image15.png" alt></p>
<p>在／下没有配置，默认为UNSET，在server1_test1下面打开，在server2_test1下面关闭。然后在钩子中实现这样的逻辑：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image16.png" alt></p>
<p>即如果没有配置test_access选项或者选项开关关闭，则403，否则放行。然后验证其效果：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image17.png" alt></p>
<p>可以看到，没有配置或者配置关闭的location，返回了403，而开关打开的server1_test1可以放行。</p>
<h4 id="2-指令出现的位置与钩子函数的关系"><a href="#2-指令出现的位置与钩子函数的关系" class="headerlink" title="2 指令出现的位置与钩子函数的关系"></a>2 指令出现的位置与钩子函数的关系</h4><p>指令出现的位置与实际造成的效果是钩子函数中的逻辑与实现决定的。<br>在access模块中（内置的access模块，不是这里的第三方模块），有一种现象就是如果将access指令配置在http块，那么所有的location块都会受到这个access指令的影响效果。而如果只将access指令配置在location块下，则只会对当前的那个location块生效。<br>这样容易有一种错觉，好像指令的位置和它管辖的范围会有关系（尽管确实是这样：）），但我们得清楚它的实现机制。<br>以test_access模块为例，如果在http层配置后会不会使得全局的location都生效呢？ 如下配置</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image18.png" alt></p>
<p>将test_access 放在了http层，且打开开关。然后访问，其结果为：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image19.png" alt></p>
<p>可以看到，放在http层的开关，并没有对任何一个location起到放行的作用。也就是说，这些talcf-&gt;passed要么没有被设置，要么被关闭了。<br>由上面的分析可以知道，在创建ngx_http_test_access_loc_conf_t结构体时候，一共创建了7份，而配置在http层的test_access指令，只是把http层的ngx_http_test_access_loc_conf_t的passed打开了。其余的ngx_http_test_access_loc_conf_t的passed仍旧是未打开状态。为了达到像access一样的“配置范围决定作用范围的效果“，需要将http层的ngx_http_test_access_loc_conf_t的passed的状态更新到各个ngx_http_test_access_loc_conf_t中，而ctx-&gt;merge_loc_conf钩子就是干这个工作的。</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image20.png" alt></p>
<p>其逻辑就是：如果子层的passed未配置（UNSET为－1），则将其上层的passed的值赋给子层的passed。（注意这行的红色字体，如果子层已经配置，则不会继承，当然，这一切都将由你自己写的merge钩子来决定）<br>然后再看访问结果：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image21.png" alt></p>
<p>ok，全部都放行。</p>
<p>所以，从这里可以看到，并不是单纯的指令的位置而决定了其影响的范围，而是钩子函数的逻辑来决定的。</p>
<h2 id="五-指令配置顺序与请求执行顺序"><a href="#五-指令配置顺序与请求执行顺序" class="headerlink" title="五 指令配置顺序与请求执行顺序"></a>五 指令配置顺序与请求执行顺序</h2><p>经常会有这样的感觉：指令配置的顺序决定了请求处理的顺序，如图所示的配置文件：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image22.png" alt></p>
<p>为了简单的做实验，这里直接用写了lua）<br>例如，上面配置了access_by_lua_file是影响整个server块的，在location/test下面配置了rewrite_by_lua_file。<br>其两个lua文件简单的输出标示：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image23.png" alt></p>
<p>然后访问 servername2:8039/test<br>虽然access_by_lua_file指令的位置是配置在rewrite_by_lua_file指令位置之前的，但是这个请求被处理的顺序没有任何关系，而是严格按照其11个阶段的顺序来执行的。<br>由于rewrite阶段在access阶段之前，故有下面的结果：</p>
<p><img src="/images/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%B5%85%E8%B0%88/image24.png" alt></p>
<p>会先执行rewrite的lua文件。（由于ngx.say的实现是直接返回了的，所以这里没有继续执行access阶段的文件，这和ngx.say的实现有关，但并不影响这里讨论的话题）</p>
<p>所以，指令的配置顺序不能和请求的执行顺序相等。</p>
<h2 id="六-rewrite指令详解"><a href="#六-rewrite指令详解" class="headerlink" title="六 rewrite指令详解"></a>六 rewrite指令详解</h2><p>//待续</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/id.jpg"
      alt="josephus.ftt">
  <p class="site-author-name" itemprop="name">josephus.ftt</p>
  <div class="site-description" itemprop="description">《红与黑》</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">josephus.ftt</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">NaN:aN</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

</body>
</html>
